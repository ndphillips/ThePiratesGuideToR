[
["index.html", "YaRrr! The Pirate’s Guide to R Chapter 1 Preface 1.1 Where did this book come from? 1.2 Who is this book for? 1.3 Why is R so great? 1.4 Why R is like a relationship… 1.5 R resources 1.6 Who am I? 1.7 Please Contribute!", " YaRrr! The Pirate’s Guide to R Nathaniel D. Phillips 2017-02-27 Chapter 1 Preface The purpose of this book is to help you learn R from the ground-up. 1.1 Where did this book come from? Let me make something very, very clear… I did not write this book. This whole story started in the Summer of 2015. I was taking a late night swim on the Bodensee in Konstanz and saw a rusty object sticking out of the water. Upon digging it out, I realized it was an ancient usb-stick with the word YaRrr inscribed on the side. Intrigued, I brought it home and plugged it into my laptop. Inside the stick, I found a single pdf file written entirely in pirate-speak. After watching several pirate movies, I learned enough pirate-speak to begin translating the text to English. Sure enough, the book turned out to be an introduction to R called The Pirate’s Guide to R. This book clearly has both massive historical and pedagogical significance. Most importantly, it turns out that pirates were programming in R well before the earliest known advent of computers. Of slightly less significance is that the book has turned out to be a surprisingly up-to-date and approachable introductory text to R. For both of these reasons, I felt it was my duty to share the book with the world. If you or spot any typos or errors, or have any recommendations for future versions of the book, please write me at YaRrr.Book@gmail.com or tweet me @YaRrrBook. 1.2 Who is this book for? While this book was originally written for pirates, I think that anyone who wants to learn R can benefit from this book. If you haven’t had an introductory course in statistics, some of the later statistical concepts may be difficult, but I’ll try my best to add brief descriptions of new topics when necessary. Likewise, if R is your first programming language, you’ll likely find the first few chapters quite challenging as you learn the basics of programming. However, if R is your first programming language, that’s totally fine as what you learn here will help you in learning other languages as well (if you choose to). Finally, while the techniques in this book apply to most data analysis problems, because my background is in experimental psychology I will cater the course to solving analysis problems commonly faced in psychological research. What this book is This book is meant to introduce you to the basic analytical tools in R, from basic coding and analyses, to data wrangling, plotting, and statistical inference. What this book is not This book does not cover any one topic in extensive detail. If you are interested in conducting analyses or creating plots not covered in the book, I’m sure you’ll find the answer with a quick Google search! 1.3 Why is R so great? As you’ve already gotten this book, you probably already have some idea why R is so great. However, in order to help prevent you from giving up the first time you run into a programming wall, let me give you a few more reasons: R is 100% free and as a result, has a huge support community. Unlike SPSS, Matlab, Excel and JMP, R is, and always will be completely free. This doesn’t just help your wallet - it means that a huge community of R programmers will constantly develop an distribute new R functionality and packages at a speed that leaves all those other packages in the dust! Unlike Fight Club, the first rule of R is “Do talk about R!” The size of the R programming community is staggering. If you ever have a question about how to implement something in R, a quick Poogle search will lead you to your answer virtually every single time. R is the presnt, and future of statistical programming. To illustrate this, look at the following three figures. These are Google trend searches for three terms: R Programming, Matlab, and SPSS. Try and guess which one is which. R is incredibly versatile. You can use R to do everything from calculating simple summary statistics, to performing complex simulations to creating gorgeous plots like the chord diagram on the right. If you can imagine an analytical task, you can almost certainly implement it in R. Using RStudio, a program to help you write R code, You can easily and seamlessly combine R code, analyses, plots, and written text into elegant documents all in one place using Sweave (R and Latex) or RMarkdown. In fact, I translated this entire book (the text, formatting, plots, code…yes, everything) in RStudio using Sweave. With RStudio and Sweave, instead of trying to manage two or three programs, say Excel, Word and (sigh) SPSS, where you find yourself spending half your time copying, pasting and formatting data, images and test, you can do everything in one place so nothing gets misread, mistyped, or forgotten. circlize::chordDiagram(matrix(sample(10), nrow = 2, ncol = 5)) Figure 1.1: A super cool chord diagram from the circlize package Analyses conducted in R are transparent, easily shareable, and reproducible. If you ask an SPSS user how they conducted a specific analyses, they will either A) Not remember, B) Try (nervously) to construct an analysis procedure on the spot that makes sense - which may or may not correspond to what they actually did months or years ago, or C) Ask you what you are doing in their house. I used to primarily use SPSS, so I speak from experience on this. If you ask an R user (who uses good programming techniques!) how they conducted an analysis, they should always be able to show you the exact code they used. Of course, this doesn’t mean that they used the appropriate analysis or interpreted it correctly, but with all the original code, any problems should be completely transparent! And most importantly of all, R is the programming language of choice for pirates. 1.4 Why R is like a relationship… Yes, R is very much like a relationship. Like relationships, there are two major truths to R programming: Figure 1.2: Yep, R will become both your best friend and your worst nightmare. The bad times will make the good times oh so much sweeter. There is nothing more frustrating than when your code does not work There is nothing more satisfying than when your code does work! Anything worth doing, from losing weight to getting a degree, takes time. Learning R is no different. Especially if this is your first experience programming, you are going to experience a lot of headaches when you get started. You will run into error after error and pound your fists against the table screaming: “WHY ISN’T MY CODE WORKING?!?!? There must be something wrong with this stupid software!!!” You will spend hours trying to find a bug in your code, only to find that - frustratingly enough, you had had an extra space or missed a comma somewhere. You’ll then wonder why you ever decided to learn R when (::sigh::) SPSS was so “nice and easy.” Figure 1.3: When you first meet R, it will look so fugly that you’ll wonder if this is all some kind of sick joke. But trust me, once you learn how to talk to it, and clean it up a bit, all your friends will be crazy jealous. Fun Fact! SPSS stands for “Shitty Piece of Shitty Shit”. True story. This is perfectly normal! Don’t get discouraged and DON’T GO BACK TO SPSS! That would be quitting on exercise altogether because you had a tough workout. Trust me, as you gain more programming experience, you’ll experience fewer and fewer bugs (though they’ll never go away completely). Once you get over the initial barriers, you’ll find yourself conducting analyses much, much faster than you ever did before. 1.5 R resources 1.5.1 R Cheatsheets Figure 1.4: The R reference card written by Tom Short is absolutely indispensable! Over the course of this book, you will be learning lots of new functions. Wouldn’t it be nice if someone created a Cheatsheet / Dictionary of many common R functions? Yes it would, and thankfully several friendly R programmers have done just that. Below is a table of some of them that I recommend. I highly encourage you to print these out and start highlighting functions as you learn them! CheatSheet Link R Basics by Tom Short https://cran.r-project.org/doc/contrib/Short-refcard.pdf R Basics by Mhairi McNeill http://github.com/rstudio/cheatsheets/raw/master/source/pdfs/base-r.pdf Advanced R by Arianne Colton and Sean Chen hhttps://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf Plotting https://www.rstudio.com/wp-content/uploads/2016/10/how-big-is-your-graph.pdf 1.5.2 Getting R help and inspiration online Here are some great resources for R help and inspiration: Site Description www.google.com If you haven’t heard of it, Google is this amazing site that gives you access to all R knowledge that has ever existed. Just ask it an R question and 99.9% of the time it will give you the answer! www.r-bloggers.com R bloggers is my go-to place to discover the latest and greatest with R. blog.revolutionanalytics.com Revolution analytics always has great R related material. www.kaggle.com Kaggle is a really cool website that posts data analysis challenges that anyone can try to solve. It also contains a wide range of real-world datasets and tutorials. 1.5.3 Other R books There are many, many excellent (non-pirate) books on R, some of which are available online for free. Here are some that I highly recommend: Book Description R for Data Science by Garrett Grolemund and Hadley Wickham The best book to learn the latest tools for elegantly doing data science. The R Book by Michael Crawley As close to an R bible as you can get. Advanced R by Hadley Wickham A truly advanced book for expert R users, especially those with a programming background. Hadley Wickham is the R guru. Discovering Statistics with R by Field, Miles and Field A classic text focusing on the theory and practice of statistical analysis with R Applied Predictive Modeling by Kuhn and Johnson A great text specializing in statistical learning aka predictive modeling aka machine learning with R. 1.6 Who am I? Figure 1.5: Like a pirate, I work best with a mug of beer within arms’ reach. My name is Nathaniel – not Nathan…not Nate…and definitely not Nat. I am a psychologist with a background in statistics and judgment and decision making. You can find my R (and non-R) related musings at http://ndphillips.github.io 1.6.1 Acknowledgements I am deeply indebted to many people for either directly or indirectly helping me make this book happen. I would especially like to thank Captain Thomas Moore and Captain Wei Linn for my early training in both statistics and R, Captain Hansjoerg Neth for teaching me LaTeX and ultimately inspiring me to write (I mean translate) this book, and Captain Dirk Wulff for teaching me almost everything I know about R. If I hadn’t been lucky enough to meet just one of these people, this book would not exist. 1.7 Please Contribute! I am grateful for comments, questions, bug reports, and requests to future editions of the book! If there’s anything you’d like to add or share, please contact me via email at yarrr.book@gmail.com, or if you are familiar with GitHub, post an issue at https://github.com/ndphillips/ThePiratesGuideToR/issues. "],
["started.html", "Chapter 2 Getting Started 2.1 Installing Base-R and RStudio 2.2 The four RStudio Windows 2.3 Packages 2.4 Reading and writing Code 2.5 Debugging", " Chapter 2 Getting Started 2.1 Installing Base-R and RStudio To use R, we’ll need to download two software packages: Base-R, and RStudio. Base-R is the basic software which contains the R programming language. RStudio is software that makes R programming easier. Of course, they are totally free and open source. 2.1.1 Check for version updates R and RStudio have been around for several years – however, they are constantly being updated with new features and bug-fixes. At the time that I am writing this sentence (09:48, Thursday, 23 February, 2017), the latest version of Base-R is 3.3.2 “Sincere Pumpkin Patch” (the versions all have funny names) which was released on 31 October, 2016, and the latest version of RStudio is 1.0.136 released on 21 December, 2016. If you have a (much) older version of R or RStudio currently installed on your computer, then you should update both R and RStudio to the newest version(s) by installing them again from scratch. If you don’t, then some of the code and packages in this book might not work. To install Base-R, click on one of the following links and follow the instructions. Operating System Link Windows http://cran.r-project.org/bin/windows/base/ Mac http://cran.r-project.org/bin/macosx/ Once you’ve installed base-R on your computer, try opening it. When you do you should see a screen like the one in Figure 2.1 (this is the Mac version). As you can see, base R is very much bare-bones software. It’s kind of the equivalent of a simple text editor that comes with your computer. Figure 2.1: {Here is how the base R application looks. While you can use the base R application alone, most people I know use RStudio – software that helps you to write and use R code more efficiently! While you can do pretty much everything you want within base-R, you’ll find that most people these days do their R programming in an application called RStudio. RStudio is a graphical user interface (GUI)-like interface for R that makes programming in R a bit easier. In fact, once you’ve installed RStudio, you’ll likely never need to open the base R application again. To download and install RStudio (around 40mb), go to one of the links above and follow the instructions. Operating System Link All http://www.rstudio.com/products/rstudio/download/ Let’s go ahead and boot up RStudio and see how she looks! 2.2 The four RStudio Windows When you open RStudio, you’ll see the following four windows (also called panes) shown in in Figure 2.2. However, your windows might be in a different order that those in Figure 2.2. If you’d like, you can change the order of the windows under RStudio preferences. You can also change their shape by either clicking the minimize or maximize buttons on the top right of each panel, or by clicking and dragging the middle of the borders of the windows. Figure 2.2: The four panes of RStudio. Now, let’s see what each window does in detail. 2.2.1 Source - Your notepad for code Figure 2.3: The Source contains all of your individual R scripts. The code won’t be evaluated until you send it to the Console. The source pane is where you create and edit ``R Scripts&quot; - your collections of code. Don’t worry, R scripts are just text files with the “.R” extension. When you open RStudio, it will automatically start a new Untitled script. Before you start typing in an untitled R script, you should always save the file under a new file name (like, “2015PirateSurvey.R”). That way, if something on your computer crashes while you’re working, R will have your code waiting for you when you re-open RStudio. You’ll notice that when you’re typing code in a script in the Source panel, R won’t actually evaluate the code as you type. To have R actually evaluate your code, you need to first ‘send’ the code to the Console (we’ll talk about this in the next section). There are many ways to send your code from the Source to the console. The slowest way is to copy and paste. A faster way is to highlight the code you wish to evaluate and clicking on the “Run” button on the top right of the Source. Alternatively, you can use the hot-key “Command + Return” on Mac, or “Control + Enter” on PC to send all highlighted code to the console. 2.2.2 Console: R’s Heart Figure 2.4: The console the calculation heart of R. All of your code will (eventually) go through here. The console is the heart of R. Here is where R actually evaluates code. At the beginning of the console you’ll see the character . This is a prompt that tells you that R is ready for new code. You can type code directly into the console after the prompt and get an immediate response. For example, if you type 1+1 into the console and press enter, you’ll see that R immediately gives an output of 2. 1+1 ## [1] 2 Try calculating 1+1 by typing the code directly into the console - then press Enter. You should see the result [1] 2. Don’t worry about the [1] for now, we’ll get to that later. For now, we’re happy if we just see the 2. Then, type the same code into the Source, and then send the code to the Console by highlighting the code and clicking the ``Run&quot; button on the top right hand corner of the Source window. Alternatively, you can use the hot-key “Command + Return” on Mac or “Control + Enter” on Windows. Tip: Try to write most of your code in a document in the Source. Only type directly into the Console to de-bug or do quick analyses. So as you can see, you can execute code either by running it from the Source or by typing it directly into the Console. However, 99% most of the time, you should be using the Source rather than the Console. The reason for this is straightforward: If you type code into the console, it won’t be saved (though you can look back on your command History). And if you make a mistake in typing code into the console, you’d have to re-type everything all over again. Instead, it’s better to write all your code in the Source. When you are ready to execute some code, you can then send “Run” it to the console. 2.2.3 Environment / History Figure 2.5: The environment panel shows you all the objects you have defined in your current workspace. You’ll learn more about workspaces in Chapter 7. The Environment tab of this panel shows you the names of all the data objects (like vectors, matrices, and dataframes) that you’ve defined in your current R session. You can also see information like the number of observations and rows in data objects. The tab also has a few clickable actions like ``Import Dataset&quot; which will open a graphical user interface (GUI) for important data into R. However, I almost never look at this menu. The History tab of this panel simply shows you a history of all the code you’ve previously evaluated in the Console. To be honest, I never look at this. In fact, I didn’t realize it was even there until I started writing this tutorial. As you get more comfortable with R, you might find the Environment / History panel useful. But for now you can just ignore it. If you want to declutter your screen, you can even just minimize the window by clicking the minimize button on the top right of the panel. 2.2.4 Files / Plots / Packages / Help The Files / Plots / Packages / Help panel shows you lots of helpful information. Let’s go through each tab in detail: Files - The files panel gives you access to the file directory on your hard drive. One nice feature of the “Files” panel is that you can use it to set your working directory - once you navigate to a folder you want to read and save files to, click “More” and then “Set As Working Directory.” We’ll talk about working directories in more detail soon. Plots - The Plots panel (no big surprise), shows all your plots. There are buttons for opening the plot in a separate window and exporting the plot as a pdf or jpeg (though you can also do this with code using the pdf() or jpeg() functions.) Let’s see how plots are displayed in the Plots panel. Run the code on the right to display a histogram of the weights of chickens stored in the ChickWeight dataset. When you do, you should see a plot similar to the one in Figure 2.6 show up in the Plots panel. hist(x = ChickWeight$weight, main = &quot;Chicken Weights&quot;, xlab = &quot;Weight&quot;, col = &quot;skyblue&quot;, border = &quot;white&quot;) Figure 2.6: The plot panel contains all of your plots, like this histogram of the distribution of chicken weights. Packages - Shows a list of all the R packages installed on your harddrive and indicates whether or not they are currently loaded. Packages that are loaded in the current session are checked while those that are installed but not yet loaded are unchecked. We’ll discuss packages in more detail in the next section. Help - Help menu for R functions. You can either type the name of a function in the search window, or use the code to search for a function with the name ?hist # How does the histogram function work? ?t.test # What about a t-test? 2.3 Packages When you download and install R for the first time, you are installing the Base R software. Base R will will contain most of the functions you’ll use on a daily basis like mean() and hist(). However, only functions written by the original authors of the R language will appear here. If you want to access data and code written by other people, you’ll need to install it as a package. An R package is simply a bunch of data, from functions, to help menus, to vignettes (examples), stored in one neat package. Figure 2.7: An R package is light a lightbulb. First you need to order it with install.packages(). Then, every time you want to use it, you need to turn it on with library() A package is like a light bulb. In order to use it, you first need to order it to your house (i.e.; your computer) by installing it. Once you’ve installed a package, you never need to install it again. However, every time you want to actually use the package, you need to turn it on by loading it. Here’s how to do it. 2.3.1 Installing a new package Installing a package simply means downloading the package code onto your personal computer. There are two main ways to install new packages. The first, and most common, method is to download them from the Comprehensive R Archive Network (CRAN). CRAN is the central repository for R packages. To install a new R package from CRAN, you can simply run the code install.packages(&quot;name&quot;), where “name” is the name of the package. For example, to download the yarrr package, which contains several data sets and functions we will use in this book, you should run the following: Figure 2.8: CRAN (Comprehensive R Archive Network) is the main source of R packages # Install the yarrr package from CRAN # You only need to install a package once! install.packages(&quot;yarrr&quot;) When you run install.packages(&quot;name&quot;) R will download the package from CRAN. If everything works, you should see some information about where the package is being downloaded from, in addition to a progress bar. Figure 2.9: When you install a new package, you’ll see some random text like this you the download progress. You don’t need to memorize this. Like ordering a light bulb, once you’ve installed a package on your computer you never need to install it again (unless you want to try to install a new version of the package). However, every time you want to use it, you need to turn it on by loading it. 2.3.2 Loading a package Once you’ve installed a package, it’s on your computer. However, just because it’s on your computer doesn’t mean R is ready to use it. If you want to use something, like a function or dataset, from a package you always need to load the package in your R session first. Just like a light bulb, you need to turn it on to use it! To load a package, you use the library() function. For example, now that we’ve installed the yarrr package, we can load it with library(&quot;yarrr&quot;): # Load the yarrr package so I can use it! # You have to load a package in every new R session! library(&quot;yarrr&quot;) Now that you’ve loaded the yarrr package, you can use any of its functions! One of the coolest functions in this package is called pirateplot(). Rather than telling you what a pirateplot is, let’s just make one. Run the following code chunk to make your own pirateplot. Don’t worry about the specifics of the code below, you’ll learn more about how all this works later. For now, just run the code and marvel at your pirateplot. # Make a pirateplot using the pirateplot() function # from the yarrr package! pirateplot(formula = weight ~ Time, data = ChickWeight, pal = &quot;xmen&quot;) There is one way in R to temporarily load a package without using the library() function. To do this, you can simply use the notation package::function notation. This notation simply tells R to load the package just for this one chunk of code. For example, I could use the pirateplot function from yarrr package as follows: # Use the pirateplot() function without loading the yarrr package first yarrr::pirateplot(formula = weight ~ Diet, data = ChickWeight) Again, you can think about the package::function method as a way to temporarily loading a package for a single line of code. One benefit of using the package::function notation is that it’s immediately clear to anyone reading the code which package contains the function. However, a drawback is that if you are using a function from a package often, it forces you to constantly retype the package name. You can use whichever method makes sense for you. 2.4 Reading and writing Code 2.4.1 Code Chunks In this book, R code is (almost) always presented in a separate gray box like this one: # A code chunk # Define a vector a as the integers from 1 to 5 a &lt;- 1:5 # Print a a ## [1] 1 2 3 4 5 # What is the mean of a? mean(a) ## [1] 3 This is called a code chunk. You should always be able to copy and paste code chunks directly into R. If you copy a chunk and it does not work for you, it is most likely because the code refers to a package, function, or object that I defined in a previous chunk. If so, read back and look for a previous chunk that contains the missing definition. 2.4.2 Comments with # Lines that begin with # are comments. If you evaluate any code that starts with #, R will just ignore that line. In this book, comments will be either be literal comments that I write directly to explain code, or they will be output generated automatically from R. For example, in the code chunk below, you see lines starting with ##. These are the output from the previous line(s) of code. When you run the code yourself, you should see the same output in your console. # This is a comment I wrote 1 + 2 ## [1] 3 # The line above (## [1] 3) is the output from the previous code that has been &#39;commented out&#39; 2.4.3 Element numbers in output [1] The output you see will often start with one or more number(s) in brackets such as [1]. This is just a visual way of telling you where the numbers occur in the output. For example, in the code below, I will print a long vector containing the multiples of 2 from 0 to 100: seq(from = 0, to = 100, by = 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 ## [18] 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 ## [35] 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 As you can see, the first line of the output starts with ## [1], and the next two lines start with [18] and [35]. This is just telling you that 0 is the [1]st element, 34 is the [18]th element, and 68 is the [35]th element. Sometimes this information will be helpful, but most of the time you can just ignore it. 2.5 Debugging When you are programming, you will always, and I do mean always, make errors (also called bugs) in your code. You might misspell a function, include an extra comma, or some days…R just won’t want to work with you (again, see section Why R is like a Relationship). Debugging will always be a challenge. However, over time you’ll learn which bugs are the most common and get faster and faster at finding and correcting them. Here are the most common bugs you’ll run into as you start your R journey. 2.5.1 R is not ready (&gt;) Another very common problem occurs when R does not seem to be responding to your code. That is, you might run some code like mean(x) expecting some output, but instead, nothing happens. This can be very frustrating because, rather than getting an error, just nothing happens at all. The most common reason for this is because R isn’t ready for new code, instead, it is waiting for you to finish code you started earlier, but never properly finished. Think about it this way, R can be in one of two states: it is either Ready (&gt;) for new code, or it is Waiting (+) for you to finish old code. To see which state R is in, all you have to do is look at the symbol on the console. The &gt; symbol means that R is Ready for new code – this is usually what you want to see. The + symbol means that R is Waiting for you to (properly) finish code you started before. If you see the + symbol, then no matter how much new code you write, R won’t actually evaluate it until you finish the code you started before. Thankfully there is an easy solution to this problem (See Figure 2.10): Just hit the escape key on your keyboard. This will cancel R’s waiting state and make it Ready! Figure 2.10: To turn R from a Waiting (+) state to a Ready (&gt;) state, just hit Escape. 2.5.2 Misspelled object or function If you spell an object or function incorrectly, you’ll receive an error like Error: could not find function or Error: object 'x' not found. In the code below, I’ll try to take the mean of a vector data, but I will misspell the function mean() data &lt;- c(1, 4, 3, 2, 1) # Misspelled function: should be mean(x), not meeen(x) meeen(data) Error: could not find function “meeen” Now, I’ll misspell the object data as dta: # Misspelled object: should be data, not dta mean(dta) Error: object ‘dta’ not found R is case-sensitive, so if you don’t use the correct capitalization you’ll receive an error. In the code below, I’ll use Mean() instead of the correct version mean() # Capitalization is wrong: should be mean(), not Mean() Mean(data) Error: could not find function “Mean” Here is the correct version where both the object data and function mean() are correctly spelled: # Correct: both the object and function are correctly spelled mean(data) ## [1] 2.2 2.5.3 Punctuation problems Another common error is having bad coding “punctuation”. By that, I mean having an extra space, missing a comma, or using a comma (,) instead of a period (.). In the code below, I’ll try to create a vector using periods instead of commas: # Wrong: Using periods (.) instead of commas (,) mean(c(1. 4. 2)) Error: unexpected numeric constant in “mean(c(1. 4.” Because I used periods instead of commas, I get the above error. Here is the correct version # Correct mean(c(1, 4, 2)) ## [1] 2.3 If you include an extra space in the middle of the name of an object or function, you’ll receive an error. In the code below, I’ll accidentally write Chick Weight instead of ChickWeight: # Wrong: Extra space in the ChickWeight object name head(Chick Weight) Error: unexpected symbol in “head(Chick Weight” Because I had an extra space in the object name, I get the above error. Here is the correction: # Correct: head(ChickWeight) "],
["jumpin.html", "Chapter 3 Jump In! 3.1 Exploring data 3.2 Descriptive statistics 3.3 Plotting 3.4 Hypothesis tests 3.5 Regression 3.6 Bayesian Statistics 3.7 Wasn’t that easy?!", " Chapter 3 Jump In! Figure 3.1: Despite what you might find at family friendly waterparks – this is NOT how real pirate swimming lessons look. What’s the first exercise on the first day of pirate swimming lessons? While it would be cute if they all had little inflatable pirate ships to swim around in – unfortunately this is not the case. Instead, those baby pirates take a walk off their baby planks so they can get a taste of what they’re in for. Turns out, learning R is the same way. Let’s jump in. In this chapter, you’ll see how easy it is to calculate basic statistics and create plots in R. Don’t worry if the code you’re running doesn’t make immediate sense – just marvel at how easy it is to do this in R! In this section, we’ll analyze a dataset called…wait for it…pirates! The dataset contains data from a survey of 1,000 pirates. The data is contained in the yarrr package, so make sure you’ve installed and loaded the package: # Install the yarrr package install.packages(&#39;yarrr&#39;) # Load the package library(yarrr) 3.1 Exploring data Next, we’ll look at the help menu for the pirates dataset using the question mark ?pirates. When you run this, you should see a small help window open up in RStudio that gives you some information about the dataset. ?pirates First, let’s take a look at the first few rows of the dataset using the head() function. This will show you the first few rows of the data. # Look at the first few rows of the data head(pirates) ## id sex age height weight headband college tattoos tchests parrots ## 2 2 male 31 209 106 yes JSSFP 9 11 0 ## 793 793 male 25 209 104 yes CCCC 8 27 9 ## 430 430 male 26 201 99 yes CCCC 4 7 1 ## 292 292 male 29 201 102 yes CCCC 9 2 3 ## 895 895 male 27 201 103 yes CCCC 12 1 1 ## 409 409 male 28 201 97 yes CCCC 7 10 0 ## favorite.pirate sword.type eyepatch sword.time beard.length ## 2 Jack Sparrow cutlass 0 1.1 21 ## 793 Anicetus cutlass 1 1.1 16 ## 430 Jack Sparrow cutlass 1 0.9 14 ## 292 Jack Sparrow sabre 1 9.9 14 ## 895 Hook cutlass 1 2.3 25 ## 409 Jack Sparrow cutlass 1 1.2 15 ## fav.pixar grogg ## 2 WALL-E 9 ## 793 Monsters University 8 ## 430 WALL-E 9 ## 292 WALL-E 6 ## 895 Brave 14 ## 409 Inside Out 7 You can look at the names of the columns in the dataset with the names() function # What are the names of the columns? names(pirates) ## [1] &quot;id&quot; &quot;sex&quot; &quot;age&quot; ## [4] &quot;height&quot; &quot;weight&quot; &quot;headband&quot; ## [7] &quot;college&quot; &quot;tattoos&quot; &quot;tchests&quot; ## [10] &quot;parrots&quot; &quot;favorite.pirate&quot; &quot;sword.type&quot; ## [13] &quot;eyepatch&quot; &quot;sword.time&quot; &quot;beard.length&quot; ## [16] &quot;fav.pixar&quot; &quot;grogg&quot; Finally, you can also view the entire dataset in a separate window using the View() function: # View the entire dataset in a new window View(pirates) 3.2 Descriptive statistics Now let’s calculate some basic statistics on the entire dataset. We’ll calculate the mean age, maximum height, and number of pirates of each sex: # What is the mean age? mean(pirates$age) ## [1] 27 # What was the tallest pirate? max(pirates$height) ## [1] 209 # How many pirates are there of each sex? table(pirates$sex) ## ## female male other ## 464 490 46 Now, let’s calculate statistics for different groups of pirates. For example, the following code will use the aggregate() function to calculate the mean age of pirates, separately for each sex. # Calculate the mean age, separately for each sex aggregate(formula = age ~ sex, data = pirates, FUN = mean) ## sex age ## 1 female 30 ## 2 male 25 ## 3 other 27 3.3 Plotting Cool stuff, now let’s make a plot! We’ll plot the relationship between pirate’s height and weight using the plot() function # Create scatterplot plot(x = pirates$height, # X coordinates y = pirates$weight) # y-coordinates Now let’s make a fancier version of the same plot by adding some customization # Create scatterplot plot(x = pirates$height, # X coordinates y = pirates$weight, # y-coordinates main = &#39;My first scatterplot of pirate data!&#39;, xlab = &#39;Height (in cm)&#39;, # x-axis label ylab = &#39;Weight (in kg)&#39;, # y-axis label pch = 16, # Filled circles col = gray(.0, .1)) # Transparent gray Now let’s make it even better by adding gridlines and a blue regression line to measure the strength of the relationship. # Create scatterplot plot(x = pirates$height, # X coordinates y = pirates$weight, # y-coordinates main = &#39;My first scatterplot of pirate data!&#39;, xlab = &#39;Height (in cm)&#39;, # x-axis label ylab = &#39;Weight (in kg)&#39;, # y-axis label pch = 16, # Filled circles col = gray(.0, .1)) # Transparent gray grid() # Add gridlines # Create a linear regression model model &lt;- lm(formula = weight ~ height, data = pirates) abline(model, col = &#39;blue&#39;) # Add regression to plot Scatterplots are great for showing the relationship between two continuous variables, but what if your independent variable is not continuous? In this case, pirateplots are a good option. Let’s create a pirateplot using the pirateplot() function to show the distribution of pirate’s age based on their favorite sword: pirateplot(formula = age ~ sword.type, data = pirates, main = &quot;Pirateplot of ages by favorite sword&quot;) Now let’s make another pirateplot showing the relationship between sex and height using a different plotting theme and the &quot;pony&quot; color palette: pirateplot(formula = height ~ sex, # Plot weight as a function of sex data = pirates, main = &quot;Pirateplot of height by sex&quot;, pal = &quot;pony&quot;, # Use the info color palette theme = 3) # Use theme 3 The &quot;pony&quot; palette is contained in the piratepal() function. Let’s see where the &quot;pony&quot; palette comes from… # Show me the pony palette! piratepal(palette = &quot;pony&quot;, plot.result = TRUE, # Plot the result trans = .1) # Slightly transparent 3.4 Hypothesis tests Now, let’s do some basic hypothesis tests. First, let’s conduct a two-sample t-test to see if there is a significant difference between the ages of pirates who do wear a headband, and those who do not: # Age by headband t-test t.test(formula = age ~ headband, data = pirates, alternative = &#39;two.sided&#39;) ## ## Welch Two Sample t-test ## ## data: age by headband ## t = 0.4, df = 100, p-value = 0.7 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -1.0 1.5 ## sample estimates: ## mean in group no mean in group yes ## 28 27 With a p-value of 0.7259, we don’t have sufficient evidence say there is a difference in the men age of pirates who wear headbands and those that do not. Next, let’s test if there a significant correlation between a pirate’s height and weight using the cor.test() function: cor.test(formula = ~ height + weight, data = pirates) ## ## Pearson&#39;s product-moment correlation ## ## data: height and weight ## t = 80, df = 1000, p-value &lt;2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.92 0.94 ## sample estimates: ## cor ## 0.93 We got a p-value of p &lt; 2.2e-16, that’s scientific notation for p &lt; .00000000000000016 – which is pretty much 0. Thus, we’d conclude that there is a significant (positive) relationship between a pirate’s height and weight. Now, let’s do an ANOVA testing if there is a difference between the number of tattoos pirates have based on their favorite sword # Create tattoos model tat.sword.lm &lt;- lm(formula = tattoos ~ sword.type, data = pirates) # Get ANOVA table anova(tat.sword.lm) ## Analysis of Variance Table ## ## Response: tattoos ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## sword.type 3 1588 529 54.1 &lt;2e-16 *** ## Residuals 996 9743 10 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Sure enough, we see another very small p-value of p &lt; 2.2e-16, suggesting that the number of tattoos pirate’s have are different based on their favorite sword. 3.5 Regression Finally, let’s run a regression analysis to see if a pirate’s age, weight, and number of tattoos (s)he has predicts how many treasure chests he/she’s found: # Create a linear regression model: DV = tchests, IV = age, weight, tattoos tchests.model &lt;- lm(formula = tchests ~ age + weight + tattoos, data = pirates) # Show summary statistics summary(tchests.model) ## ## Call: ## lm(formula = tchests ~ age + weight + tattoos, data = pirates) ## ## Residuals: ## Min 1Q Median 3Q Max ## -33.30 -15.83 -6.86 8.41 119.97 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.1908 7.1844 0.72 0.47 ## age 0.7818 0.1344 5.82 8e-09 *** ## weight -0.0901 0.0718 -1.25 0.21 ## tattoos 0.2540 0.2255 1.13 0.26 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 24 on 996 degrees of freedom ## Multiple R-squared: 0.0406, Adjusted R-squared: 0.0377 ## F-statistic: 14 on 3 and 996 DF, p-value: 5.75e-09 It looks like the only significant predictor of the number of treasure chests that a pirate has found is his/her age. There does not seem to be significant effect of weight or tattoos. 3.6 Bayesian Statistics Now, let’s repeat some of our previous analyses with Bayesian versions. First we’ll install and load the package which contains the Bayesian statistics functions we’ll use: # Install and load the BayesFactor package install.packages(&#39;BayesFactor&#39;) library(BayesFactor) Now that the packages is installed and loaded, we’re good to go! Let’s do a Bayesian version of our earlier t-test asking if pirates who wear a headband are older or younger than those who do not. # Bayesian t-test comparing the age of pirates with and without headbands ttestBF(formula = age ~ headband, data = pirates) ## Bayes factor analysis ## -------------- ## [1] Alt., r=0.707 : 0.12 ±0% ## ## Against denominator: ## Null, mu1-mu2 = 0 ## --- ## Bayes factor type: BFindepSample, JZS It looks like we got a Bayes factor of 0.12 which is strong evidence for the null hypothesis (that the mean age does not differ between pirates with and without headbands) 3.7 Wasn’t that easy?! Wait…wait…WAIT! Did you seriously just calculate descriptive statistics, a t-test, an ANOVA, and a regression, create a scatterplot and a pirateplot, AND do both a Bayesian t-test and regression analysis. Yup. Imagine how long it would have taken to explain how to do all that in SPSS. And while you haven’t really learned how R works yet, I’d bet my beard that you could easily alter the previous code to do lots of other analyses. Of course, don’t worry if some or all of the previous code didn’t make sense. Soon…it will all be clear. Now that you’ve jumped in, let’s learn how to swim. "],
["basics.html", "Chapter 4 The Basics 4.1 The command-line (Console) 4.2 Writing R scripts in an editor 4.3 A brief style guide: Commenting and spacing 4.4 Objects and functions 4.5 Test your R might!", " Chapter 4 The Basics If you’re like most people, you think of R as a statistics program. However, while R is definitely the coolest, most badass, pirate-y way to conduct statistics – it’s not really a program. Rather, it’s a programming that was written by and for statisticians. To learn more about the history of R…just…you know…Google it. Figure 4.1: Ross Ihaka and Robert Gentlemen. You have these two pirates to thank for creating R! You might not think much of them now, but by the end of this book there’s a good chance you’ll be dressing up as one of them on Halloween. In this chapter, we’ll go over the basics of the R language and the RStudio programming environment. 4.1 The command-line (Console) Figure 4.2: Yep. R is really just a fancy calculator. This R programming device was found on a shipwreck on the Bodensee in Germany. I stole it from a museum and made a pretty sweet plot with it. But I don’t want to show it to you. R code, on its own, is just text. You can write R code in a new script within R or RStudio, or in any text editor. Hell, you can write R code on Twitter if you want. However, just writing the code won’t do the whole job – in order for your code to be executed (aka, interpreted) you need to send it to R’s command-line interpreter. In RStudio, the command-line interpreter is called the Console. Figure 4.3: You can always type code directly into the command line to get an immediate response. In R, the command-line interpreter starts with the &gt; symbol. This is called the prompt. Why is it called the prompt? Well, it’s “prompting” you to feed it with some R code. The fastest way to have R evaluate code is to type your R code directly into the command-line interpreter. For example, if you type 1+1 into the interpreter and hit enter you’ll see the following 1+1 ## [1] 2 As you can see, R returned the (thankfully correct) value of 2. You’ll notice that the console also returns the text [1]. This is just telling you you the index of the value next to it. Don’t worry about this for now, it will make more sense later. As you can see, R can, thankfully, do basic calculations. In fact, at its heart, R is technically just a fancy calculator. But that’s like saying Michael Jordan is just a fancy ball bouncer or Donald Trump is just a orange with a dead fox on his head. It (and they), are much more than that. 4.2 Writing R scripts in an editor There are certainly many cases where it makes sense to type code directly into the console. For example, to open a help menu for a new function with the ? command, to take a quick look at a dataset with the head() function, or to do simple calculations like 1+1, you should type directly into the console. However, the problem with writing all your code in the console is that nothing that you write will be saved. So if you make an error, or want to make a change to some earlier code, you have to type it all over again. Not very efficient. For this (and many more reasons), you’ll should write any important code that you want to save as an R script. An R script is just a bunch of R code in a single file. You can write an R script in any text editor, but you should save it with the .R suffix to make it clear that it contains R code.} in an editor. In RStudio, you’ll write your R code in the…wait for it…Source window. To start writing a new R script in RStudio, click File – New File – R Script. Shortcut! To create a new script in R, you can also use the command–shift–N shortcut on Mac. I don’t know what it is on PC…and I don’t want to know. When you open a new script, you’ll see a blank page waiting for you to write as much R code as you’d like. In Figure 4.4, I have a new script called examplescript with a few random calculations. Figure 4.4: Here’s how a new script looks in the editor window on RStudio. The code you type won’t be executed until you send it to the console. You can have several R scripts open in the source window in separate tabs (like I have above). 4.2.1 Send code from an source to the console Figure 4.5: To evaluate code from the source, highlight it and run it. When you type code into an R script, you’ll notice that, unlike typing code into the Console, nothing happens. In order for R to interpret the code, you need to send it from the Editor to the Console. There are a few ways to do this, here are the three most common ways: Copy the code from the Editor (or anywhere that has valid R code), and paste it into the Console (using Command–V). Highlight the code you want to run (with your mouse or by holding Shift), then use the Command–Return shortcut (see Figure 4.6). Place the cursor on a single line you want to run, then use the Command–Return shortcut to run just that line. Figure 4.6: Ah…the Command–Return shortcut (Control–Enter on PC) to send highlighted code from the Editor to the Console. Get used to this shortcut people. You’re going to be using this a lot 99% of the time, I use method 2, where I highlight the code I want, then use the Command–Return shortcut . However, method 3 is great for trouble-shooting code line-by-line. 4.3 A brief style guide: Commenting and spacing Like all programming languages, R isn’t just meant to be read by a computer, it’s also meant to be read by other humans – or very well-trained dolphins. For this reason, it’s important that your code looks nice and is understandable to other people and your future self. To keep things brief, I won’t provide a complete style guide – instead I’ll focus on the two most critical aspects of good style: commenting and spacing. Figure 4.7: As Stan discovered in season six of South Park, your future self is a lazy, possibly intoxicated moron. So do your future self a favor and make your code look nice. Also maybe go for a run once in a while. 4.3.1 Commenting code with the # (pound) sign Comments are completely ignored by R and are just there for whomever is reading the code. You can use comments to explain what a certain line of code is doing, or just to visually separate meaningful chunks of code from each other. Comments in R are designated by a # (pound) sign. Whenever R encounters a # sign, it will ignore all the code after the # sign on that line. Additionally, in most coding editors (like RStudio) the editor will display comments in a separate color than standard R code to remind you that it’s a comment: Here is an example of a short script that is nicely commented. Try to make your scripts look like this! # Author: Pirate Jack # Title: My nicely commented R Script # Date: None today :( # Step 1: Load the yarrr package library(yarrr) # Step 2: See the column names in the movies dataset names(movies) # Step 3: Calculations # What percent of movies are sequels? mean(movies$sequel, na.rm = T) # How much did Pirate&#39;s of the Caribbean: On Strager Tides make? movies$revenue.all[movies$name == &#39;Pirates of the Caribbean: On Stranger Tides&#39;] I cannot stress enough how important it is to comment your code! Trust me, even if you don’t plan on sharing your code with anyone else, keep in mind that your future self will be reading it in the future. 4.3.2 Spacing Howwouldyouliketoreadabookiftherewerenospacesbetweenwords? I’mguessingyouwouldn’t. Soeverytimeyouwritecodewithoutproperspacing,rememberthissentence. Commenting isn’t the only way to make your code legible. It’s important to make appropriate use of spaces and line breaks. For example, I include spaces between arithmetic operators (like =, + and -) and after commas (which we’ll get to later). For example, look at the following code: Figure 4.8: Don’t make your code look like what a sick Triceratops with diarrhea left behind for Jeff Goldblum. # Shitty looking code a&lt;-(100+3)-2 mean(c(a/100,642564624.34)) t.test(formula=revenue.all~sequel,data=movies) plot(x=movies$budget,y=movies$dvd.usa,main=&quot;myplot&quot;) That code looks like shit. Don’t write code like that. It makes my eyes hurt. Now, let’s use some liberal amounts of commenting and spacing to make it look less shitty. # Some meaningless calculations. Not important a &lt;- (100 + 3) - 2 mean(c(a / 100, 642564624.34)) # t.test comparing revenue of sequels v non-sequels t.test(formula = revenue.all ~ sequel, data = movies) # A scatterplot of budget and dvd revenue. # Hard to see a relationship plot(x = movies$budget, y = movies$dvd.usa, main = &quot;myplot&quot;) See how much better that second chunk of code looks? Not only do the comments tell us the purpose behind the code, but there are spaces and line-breaks separating distinct elements. There are a lot more aspects of good code formatting. For a list of recommendations on how to make your code easier to follow, check out Google’s own company R Style guide at https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml 4.4 Objects and functions To understand how R works, you need to know that R revolves around two things: objects and functions. Almost everything in R is either an object or a function. In the following code chunk, I’ll define a simple object called tattoos using a function c(): # 1: Create a vector object called tattoos tattoos &lt;- c(4, 67, 23, 4, 10, 35) # 2: Apply the mean() function to the tattoos object mean(tattoos) ## [1] 24 What is an object? An object is a thing – like a number, a dataset, a summary statistic like a mean or standard deviation, or a statistical test. Objects come in many different shapes and sizes in R. There are simple objects like which represent single numbers, vectors (like our tattoos object above) which represent several numbers, more complex objects like dataframes which represent tables of data, and even more complex objects like hypothesis tests or regression which contain all sorts of statistical information. Different types of objects have different attributes. For example, a vector of data has a length attribute (i.e.; how many numbers are in the vector), while a hypothesis test has many attributes such as a test-statistic and a p-value. Don’t worry if this is a bit confusing now – it will all become clearer when you meet these new objects in person in later chapters. For now, just know that objects in R are things, and different objects have different attributes. What is a function? A function is a procedure that typically takes one or more objects as arguments (aka, inputs), does something with those objects, then returns a new object. For example, the mean() function we used above takes a vector object, like tattoos, of numeric data as an argument, calculates the arithmetic mean of those data, then returns a single number (a scalar) as a result.A great thing about R is that you can easily create your own functions that do whatever you want – but we’ll get to that much later in the book. Thankfully, R has hundreds (thousands?) of built-in functions that perform most of the basic analysis tasks you can think of. 99% of the time you are using R, you will do the following: 1) Define objects. 2) Apply functions to those objects. 3) Repeat!. Seriously, that’s about it. However, as you’ll soon learn, the hard part is knowing how to define objects they way you want them, and knowing which function(s) will accomplish the task you want for your objects. 4.4.1 Numbers versus characters For the most part, objects in R come in one of two flavors: numeric and character. It is very important to keep these two separate as certain functions, like mean(), and max() will only work for numeric objects, while functions like grep() and strtrim() only work for character objects. A numeric object is just a number like 1, 10 or 3.14. You don’t have to do anything special to create a numeric object, just type it like you were using a calculator. # These are all numeric objects 1 10 3.14 A character object is a name like &quot;Madisen&quot;, &quot;Brian&quot;, or &quot;University of Konstanz&quot;. To specify a character object, you need to include quotation marks &quot;&quot; around the text. # These are all character objects &quot;Madisen&quot; &quot;Brian&quot; &quot;10&quot; If you try to perform a function or operation meant for a numeric object on a character object (and vice-versa), R will yell at you. For example, here’s what happens when I try to take the mean of the two character objects &quot;1&quot; and &quot;10&quot;: # This will return an error because the arguments are not numeric! mean(c(&quot;1&quot;, &quot;10&quot;)) Warning message: argument is not numeric or logical, returning NA If I make sure that the arguments are numeric (by not including the quotation marks), I won’t receive the error: # This is ok! mean(c(1, 10)) ## [1] 5.5 4.4.2 Creating new objects with &lt;- By now you know that you can use R to do simple calculations. But to really take advantage of R, you need to know how to create and manipulate objects. All of the data, analyses, and even plots, you use and create are, or can be, saved as objects in R. For example the movies dataset which we’ve used before is an object stored in the yarrr package. This object was defined in the yarrr package with the name movies. When you loaded the yarrr package with the library('yarrr') command, you told R to give you access to the movies object. Once the object was loaded, we could use it to calculate descriptive statistics, hypothesis tests, and to create plots. To create new objects in R, you need to do object assignment. Object assignment is our way of storing information, such as a number or a statistical test, into something we can easily refer to later. This is a pretty big deal. Object assignment allows us to store data objects under relevant names which we can then use to slice and dice specific data objects anytime we’d like to. To do an assignment, we use the almighty &lt;- operator called assign To assign something to a new object (or to change an existing object), use the notation object &lt;- ...}, where object is the new (or updated) object, and ... is whatever you want to store in object. Let’s start by creating a very simple object called a and assigning the value of 100 to it: Good object names strike a balance between being easy to type (i.e.; short names) and interpret. If you have several datasets, it’s probably not a good idea to name them a, b, c because you’ll forget which is which. However, using long names like March2015Group1OnlyFemales will give you carpel tunnel syndrome. # Create a new object called a with a value of 100 a &lt;- 100 Once you run this code, you’ll notice that R doesn’t tell you anything. However, as long as you didn’t type something wrong, R should now have a new object called a which contains the number 100. If you want to see the value, you need to call the object by just executing its name. This will print the value of the object to the console: # Print the object a a ## [1] 100 Now, R will print the value of a (in this case 100) to the console. If you try to evaluate an object that is not yet defined, R will return an error. For example, let’s try to print the object b which we haven’t yet defined: b Error: object ‘b’ not found As you can see, R yelled at us because the object b hasn’t been defined yet. Once you’ve defined an object, you can combine it with other objects using basic arithmetic. Let’s create objects a and b and play around with them. a &lt;- 1 b &lt;- 100 # What is a + b? a + b ## [1] 101 # Assign a + b to a new object (c) c &lt;- a + b # What is c? c ## [1] 101 4.4.2.1 To change an object, you must assign it again! Normally I try to avoid excessive emphasis, but because this next sentence is so important, I have to just go for it. Here it goes… To change an object, you assign it again! No matter what you do with an object, if you don’t assign it again, it won’t change. For example, let’s say you have an object z with a value of 0. You’d like to add 1 to z in order to make it 1. To do this, you might want to just enter z + 1 – but that won’t do the job. Here’s what happens if you don’t assign it again: z &lt;- 0 z + 1 ## [1] 1 Ok! Now let’s see the value of z z ## [1] 0 Damn! As you can see, the value of z is still 0! What went wrong? Oh yeah… To change an object, you must assign it again! The problem is that when we wrote z + 1 on the second line, R thought we just wanted it to calculate and print the value of z + 1, without storing the result as a new z object. If we want to actually update the value of z, we need to reassign the result back to z as follows: z &lt;- 0 z &lt;- z + 1 # Now I&#39;m REALLY changing z z ## [1] 1 Phew, z is now 1. Because we used assignment, z has been updated. About freaking time. 4.4.3 How to name objects You can create object names using any combination of letters and a few special characters (like . and _). Here are some valid object names # Valid object names group.mean &lt;- 10.21 my.age &lt;- 32 FavoritePirate &lt;- &quot;Jack Sparrow&quot; sum.1.to.5 &lt;- 1 + 2 + 3 + 4 + 5 All the object names above are perfectly valid. Now, let’s look at some examples of invalid object names. These object names are all invalid because they either contain spaces, start with numbers, or have invalid characters: # Invalid object names! famale ages &lt;- 50 # spaces 5experiment &lt;- 50 # starts with a number a! &lt;- 50 # has an invalid character If you try running the code above in R, you will receive a warning message starting with Error: unexpected symbol . Anytime you see this warning in R, it almost always means that you have a naming error of some kind. 4.4.3.1 R is case-sensitive! Figure 4.9: Like a text message, you should probably watch your use of capitalization in R. Like English, R is case-sensitive – it R treats capital letters differently from lower-case letters. For example, the four following objects Plunder, plunder and PLUNDER are totally different objects in R: # These are all different objects Plunder &lt;- 1 plunder &lt;- 100 PLUNDER &lt;- 5 I try to avoid using too many capital letters in object names because they require me to hold the shift key. This may sound silly, but you’d be surprised how much easier it is to type mydata than MyData 100 times. 4.4.4 Example: Pirates of The Caribbean Let’s do a more practical example – we’ll define an object called blackpearl.usd which has the global revenue of Pirates of the Caribbean: Curse of the Black Pearl in U.S. dollars. A quick Google search showed me that the revenue was $634,954,103. I’ll create the new object using assignment: blackpearl.usd &lt;- 634954103 Now, my fellow European pirates might want to know how much this is in Euros. Let’s create a new object called {blackpearl.eur which converts our original value to Euros by multiplying the original amount by 0.88 (assuming 1 USD = 0.88 EUR) blackpearl.eur &lt;- blackpearl.usd * 0.88 blackpearl.eur ## [1] 5.6e+08 It looks like the movie made 558,759,611 in Euros. Not bad. Now, let’s see how much more Pirates of the Caribbean 2: Dead Man’s Chest made compared to “Curse of the Black Pearl.” Another Google search uncovered that Dead Man’s Chest made $1,066,215,812 (that wasn’t a mistype, the freaking movie made over a billion dollars). deadman.usd &lt;- 1066215812 Now, I’ll divide deadman.usd by blackpearl.usd: deadman.usd / blackpearl.usd ## [1] 1.7 It looks like “Dead Man’s Chest” made 168% as much as “Curse of the Black Pearl” - not bad for two movies based off of a ride from Disneyland. 4.5 Test your R might! Create a new R script. Using comments, write your name, the date, and “Testing my Chapter 2 R Might” at the top of the script. Write your answers to the rest of these exercises on this script, and be sure to copy and paste the original questions using comments! Your script should only contain valid R code and comments. Which (if any) of the following objects names is/are invalid? thisone &lt;- 1 THISONE &lt;- 2 1This &lt;- 3 this.one &lt;- 4 This.1 &lt;- 5 ThIS.....ON...E &lt;- 6 This!On!e &lt;- 7 lkjasdfkjsdf &lt;- 8 2015 was a good year for pirate booty - your ship collected 100,800 gold coins. Create an object called gold.in.2015 and assign the correct value to it. Oops, during the last inspection we discovered that one of your pirates Skippy McGee hid 800 gold coins in his underwear. Go ahead and add those gold coins to the object gold.in.2015. Next, create an object called plank.list with the name of the pirate thief. Look at the code below. What will R return after the third line? Make a prediction, then test the code yourself. a &lt;- 10 a + 10 a "],
["scalersvectors.html", "Chapter 5 Scalers and vectors 5.1 Scalars 5.2 Vectors 5.3 Generating random data 5.4 Test your R might!", " Chapter 5 Scalers and vectors Figure 5.1: Visual depiction of a scalar and vector. Deep shit. Wait until we get to matrices - you’re going to lose it. # Crew information captain.name &lt;- &quot;Jack&quot; captain.age &lt;- 33 crew.names &lt;- c(&quot;Heath&quot;, &quot;Vincent&quot;, &quot;Maya&quot;, &quot;Becki&quot;) crew.ages &lt;- c(19, 35, 22, 44) crew.sex &lt;- c(rep(&quot;M&quot;, times = 2), rep(&quot;F&quot;, times = 2)) crew.ages.decade &lt;- crew.ages / 10 # Earnings over first 10 days at sea days &lt;- 1:10 gold &lt;- seq(from = 10, to = 100, by = 10) silver &lt;- rep(50, times = 10) total &lt;- gold + silver People are not objects. But R is full of them. Here are some of the basic ones. 5.1 Scalars The simplest object type in R is a scalar. A scalar object is just a single value like a number or a name. In the previous chapter we defined several scalar objects. Here are examples of numeric scalars: # Examples of numeric scalers a &lt;- 100 b &lt;- 3 / 100 c &lt;- (a + b) / b Scalars don’t have to be numeric, they can also be characters (also known as strings). In R, you denote characters using quotation marks. Here are examples of character scalars: # Examples of character scalers d &lt;- &quot;ship&quot; e &lt;- &quot;cannon&quot; f &lt;- &quot;Do any modern armies still use cannons?&quot; As you can imagine, R treats numeric and character scalars differently. For example, while you can do basic arithmetic operations on numeric scalars – they won’t work on character scalars. If you try to perform numeric operations (like addition) on character scalars, you’ll get an error like this one: a &lt;- &quot;1&quot; b &lt;- &quot;2&quot; a + b Error in a + b: non-numeric argument to binary operator If you see an error like this one, it means that you’re trying to apply numeric operations to character objects. That’s just sick and wrong. 5.2 Vectors Now let’s move onto vectors. A vector object is just a combination of several scalars stored as a single object. For example, the numbers from one to ten could be a vector of length 10, and the characters in the English alphabet could be a vector of length 26. Like scalars, vectors can be either numeric or character (but not both!). There are many ways to create vectors in R. Here are the methods we will cover in this chapter: Functions to create vectors. Function Example Result c(a, b, ...) c(1, 5, 9) 1, 5, 9 a:b 1:5 1, 2, 3, 4, 5 seq(from, to, by, length.out) seq(from = 0, to = 6, by = 2) 0, 2, 4, 6 rep(x, times, each, length.out) rep(c(7, 8), times = 2, each = 2) 7, 7, 8, 8, 7, 7, 8, 8 The simplest way to create a vector is with the c() function. The c here stands for concatenate, which means “bring them together”. The c() function takes several scalars as arguments, and returns a vector containing those objects. When using c(), place a comma in between the objects (scalars or vectors) you want to combine: Let’s use the c() function to create a vector called a containing the integers from 1 to 5. # Create an object a with the integers from 1 to 5 a &lt;- c(1, 2, 3, 4, 5) # Print the result a ## [1] 1 2 3 4 5 As you can see, R has stored all 5 numbers in the object a. Thanks R! You can also create longer vectors by combining vectors you have already defined. Let’s create a vector of the numbers from 1 to 10 by first generating a vector a from 1 to 5, and a vector b from 6 to 10 then combine them into a single vector x: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(6, 7, 8, 9, 10) x &lt;- c(a, b) x ## [1] 1 2 3 4 5 6 7 8 9 10 You can also create character vectors by using the c() function to combine character scalars into character vectors: Figure 5.2: This is not a pipe. It is a character vector. char.vec &lt;- c(&quot;Leci&quot;, &quot;nest&quot;, &quot;pas&quot;, &quot;une&quot;, &quot;pipe&quot;) char.vec ## [1] &quot;Leci&quot; &quot;nest&quot; &quot;pas&quot; &quot;une&quot; &quot;pipe&quot; While the c() function is the most straightforward way to create a vector, it’s also one of the most tedious. For example, let’s say you wanted to create a vector of all integers from 1 to 100. You definitely don’t want to have to type all the numbers into a c() operator. Thankfully, R has many simple built-in functions for generating numeric vectors. Let’s start with three of them: a:b, seq(), and rep(): 5.2.1 a:b The a:b function takes two numeric scalars a and b as arguments, and returns a vector of numbers from the starting point a to the ending point b in steps of 1. Here are some examples of the a:b function in action. As you’ll see, you can go backwards or forwards, or make sequences between non-integers: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 2.5:8.5 ## [1] 2.5 3.5 4.5 5.5 6.5 7.5 8.5 5.2.2 seq() Argument Definition from The start of the sequence to The end of the sequence by The step-size of the sequence length.out The desired length of the final sequence (only use if you don’t specify by) The seq() function is a more flexible version of a:b. Like a:b, seq() allows you to create a sequence from a starting number to an ending number. However, seq()}, has additional arguments that allow you to specify either the size of the steps between numbers, or the total length of the sequence: The seq() function has two new arguments by and length.out. If you use the by argument, the sequence will be in steps of the input to the by argument: # Create the numbers from 1 to 10 in steps of 1 seq(from = 1, to = 10, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 # Integers from 0 to 100 in steps of 10 seq(from = 0, to = 100, by = 10) ## [1] 0 10 20 30 40 50 60 70 80 90 100 If you use the length.out argument, the sequence will have length equal to length.out. # Create 10 numbers from 1 to 5 seq(from = 1, to = 5, length.out = 10) ## [1] 1.0 1.4 1.9 2.3 2.8 3.2 3.7 4.1 4.6 5.0 # 3 numbers from 0 to 100 seq(from = 0, to = 100, length.out = 3) ## [1] 0 50 100 5.2.3 rep() Argument Definition x A scalar or vector of values to repeat times The number of times to repeat x each The number of times to repeat each value within x length.out The desired length of the final sequence Figure 5.3: Not a good depiction of a rep in R. The rep() function allows you to repeat a scalar (or vector) a specified number of times, or to a desired length. Let’s do some reps. rep(x = 3, times = 10) ## [1] 3 3 3 3 3 3 3 3 3 3 rep(x = c(1, 2), each = 3) ## [1] 1 1 1 2 2 2 rep(x = 1:3, length.out = 10) ## [1] 1 2 3 1 2 3 1 2 3 1 As you can see, you can can include an a:b call within a rep()! You can even combine the times and each arguments within a single rep() function. For example, here’s how to create the sequence {1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3} with one call to rep(): rep(x = 1:3, each = 2, times = 2) ## [1] 1 1 2 2 3 3 1 1 2 2 3 3 Warning! Vectors contain either numbers or characters, not both A vector can only contain one type of scalar: either numeric or character. If you try to create a vector with numeric and character scalars, then R will convert all of the numeric scalars to characters. In the next code chunk, I’ll create a new vector called my.vec that contains a mixture of numeric and character scalars. my.vec &lt;- c(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3) my.vec ## [1] &quot;a&quot; &quot;1&quot; &quot;b&quot; &quot;2&quot; &quot;c&quot; &quot;3&quot; As you can see from the output, my.vec is stored as a character vector where all the numbers are converted to characters. 5.3 Generating random data Because R is a language built for statistics, it contains many functions that allow you generate random data – either from a vector of data that you specify (like Heads or Tails from a coin), or from an established probability distribution, like the Normal or Uniform distribution. In the next section we’ll go over the standard sample() function for drawing random values from a vector. We’ll then cover some of the most commonly used probability distributions: Normal and Uniform. 5.3.1 sample() Argument Definition x A vector of outcomes you want to sample from. For example, to simulate coin flips, you’d enter x = c(&quot;H&quot;, &quot;T&quot;) size The number of samples you want to draw. The default is the length of x. replace Should sampling be done with replacement? If FALSE (the default value), then each outcome in x can only be drawn once. If TRUE, then each outcome in x can be drawn multiple times. prob A vector of probabilities of the same length as x indicating how likely each outcome in x is. The vector of probabilities you give as an argument should add up to one. If you don’t specify the prob argument, all outcomes will be equally likely. The sample() function allows you to draw random samples of elements (scalars) from a vector. For example, if you want to simulate the 100 flips of a fair coin, you can tell the sample function to sample 100 values from the vector [“Heads”, “Tails”]. Or, if you need to randomly assign people to either a “Control” or “Test” condition in an experiment, you can randomly sample values from the vector [“Control”, “Test”]: Let’s use sample() to draw 10 samples from a vector of integers from 1 to 10. # From the integers 1:10, draw 5 numbers sample(x = 1:10, size = 5) ## [1] 6 5 10 4 7 5.3.1.1 replace = TRUE If you don’t specify the replace argument, R will assume that you are sampling without replacement. In other words, each element can only be sampled once. If you want to sample with replacement, use the replace = TRUE argument: Think about replacement like drawing balls from a bag. Sampling with replacement (replace = TRUE) means that each time you draw a ball, you return the ball back into the bag before drawing another ball. Sampling without replacement (replace = FALSE) means that after you draw a ball, you remove that ball from the bag so you can never draw it again. # Draw 30 samples from the integers 1:5 with replacement sample(x = 1:5, size = 10, replace = TRUE) ## [1] 1 1 1 1 2 5 1 5 2 3 If you try to draw a large sample from a vector replacement, R will return an error because it runs out of things to draw: # You CAN&#39;T draw 10 samples without replacement from # a vector with length 5 sample(x = 1:5, size = 10) Error: cannot take a sample larger than the population when ‘replace = FALSE’ To fix this, just tell R that you want to sample with replacement: # You CAN draw 10 samples with replacement from a # vector of length 5 sample(x = 1:5, size = 10, replace = TRUE) ## [1] 3 3 5 5 2 1 1 3 4 2 To specify how likely each element in the vector x should be selected, use the prob argument. The length of the prob argument should be as long as the x argument. For example, let’s draw 10 samples (with replacement) from the vector [“a”, “b”], but we’ll make the probability of selecting “a” to be .90, and the probability of selecting “b” to be .10 sample(x = c(&quot;a&quot;, &quot;b&quot;), prob = c(.9, .1), size = 10, replace = TRUE) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; 5.3.1.2 Ex: Simulating coin flips Let’s simulate 10 flips of a fair coin, were the probably of getting either a Head or Tail is .50. Because all values are equally likely, we don’t need to specify the prob argument sample(x = c(&quot;H&quot;, &quot;T&quot;), # The possible values of the coin size = 10, # 10 flips replace = TRUE) # Sampling with replacement ## [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; Now let’s change it by simulating flips of a biased coin, where the probability of Heads is 0.8, and the probability of Tails is 0.2. Because the probabilities of each outcome are no longer equal, we’ll need to specify them with the prob argument: sample(x = c(&quot;H&quot;, &quot;T&quot;), prob = c(.8, .2), # Make the coin biased for Heads size = 10, replace = TRUE) ## [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; As you can see, our function returned a vector of 10 values corresponding to our sample size of 10. 5.3.1.3 Ex: Coins from a chest Now, let’s sample drawing coins from a treasure chest Let’s say the chest has 100 coins: 20 gold, 30 silver, and 50 bronze. Let’s draw 10 random coins from this chest. # Create chest with the 100 coins chest &lt;- c(rep(&quot;gold&quot;, 20), rep(&quot;silver&quot;, 30), rep(&quot;bronze&quot;, 50)) # Draw 10 coins from the chest sample(x = chest, size = 10) ## [1] &quot;bronze&quot; &quot;silver&quot; &quot;silver&quot; &quot;silver&quot; &quot;silver&quot; &quot;bronze&quot; &quot;bronze&quot; ## [8] &quot;gold&quot; &quot;silver&quot; &quot;bronze&quot; The output of the sample() function above is a vector of 10 strings indicating the type of coin we drew on each sample. And like any random sampling function, this code will likely give you different results every time you run it! See how long it takes you to get 10 gold coins… In the next section, we’ll cover how to generate random data from specified probability distributions. What is a probability distribution? Well, it’s simply an equation – also called a likelihood function – that indicates how likely certain numerical values are to be drawn. We can use probability distributions to represent different types of data. For example, imagine you need to hire a new group of pirates for your crew. You have the option of hiring people form one of two different pirate training colleges that produce pirates of varying quality. One college “Pirate Training Unlimited” might tend to pirates that are generally ok - never great but never terrible. While another college “Unlimited Pirate Training” might produce pirates with a wide variety of quality, from very low to very high. In Figure 5.4 I plotted 5 example pirates from each college, where each pirate is shown as a ball with a number written on it. As you can see, pirates from PTU all tend to be clustered between 40 and 60 (not terrible but not great), while pirates from UPT are all over the map, from 0 to 100. We can use probability distributions (in this case, the uniform distribution) to mathematically define how likely any possible value is to be drawn at random from a distribution. We could describe Pirate Training Unlimited with a uniform distribution with a small range, and Unlimited Pirate Training with a second uniform distribution with a wide range. Figure 5.4: Sampling 5 potential pirates from two different pirate colleges. Pirate Training Unlimited (PTU) consistently produces average pirates (with scores between 40 and 60), while Unlimited Pirate Training (UPT), produces a wide range of pirates from 0 to 100. In the next two sections, I’ll cover the two most common distributions: The Normal and the Uniform. However, R contains many more distributions than just these two. To see them all, look at the help menu for Distributions: # See all distributions included in Base R ?Distributions 5.3.2 Normal (Gaussian) Figure 5.5: Three different normal distributions with different means and standard deviations Argument Definition n The number of observations to draw from the distribution. mean The mean of the distribution. sd The standard deviation of the distribution. The Normal (a.k.a “Gaussian”) distribution is probably the most important distribution in all of statistics. The Normal distribution is bell-shaped, and has two parameters: a mean and a standard deviation. To generate samples from a normal distribution in R, we use the function rnorm() # 5 samples from a Normal dist with mean = 0, sd = 1 rnorm(n = 5, mean = 0, sd = 1) ## [1] 1.23 0.60 -2.49 2.01 -0.83 # 3 samples from a Normal dist with mean = -10, sd = 15 rnorm(n = 3, mean = -10, sd = 15) ## [1] -17.5 -22.1 -5.8 Again, because the sampling is done randomly, you’ll get different values each time you run rnorm() 5.3.3 Uniform Figure 5.6: The Uniform distribution - known colloquially as the Anthony Davis distribution. Next, let’s move on to the Uniform distribution. The Uniform distribution gives equal probability to all values between its minimum and maximum values. In other words, everything between its lower and upper bounds are equally likely to occur. To generate samples from a uniform distribution,use the function runif(), the function has 3 arguments: Argument Definition n The number of observations to draw from the distribution. min The lower bound of the Uniform distribution from which samples are drawn max The upper bound of the Uniform distribution from which samples are drawn Here are some samples from two different Uniform distributions: # 5 samples from Uniform dist with bounds at 0 and 1 runif(n = 5, min = 0, max = 1) ## [1] 0.67 0.40 0.68 0.32 0.63 # 10 samples from Uniform dist with bounds at -100 and +100 runif(n = 10, min = -100, max = 100) ## [1] -75.0 41.8 -68.2 -63.1 -54.1 74.6 81.8 -92.9 -5.4 94.2 5.3.4 Notes on random samples 5.3.4.1 Random samples will always change Every time you draw a sample from a probability distribution, you’ll (likely) get a different result. For example, see what happens when I run the following two commands (you’ll learn the rnorm() function on the next page…) # Draw a sample of size 5 from a normal distribution with mean 100 and sd 10 rnorm(n = 5, mean = 100, sd = 10) ## [1] 103 99 133 103 99 # Do it again! rnorm(n = 5, mean = 100, sd = 10) ## [1] 102 101 109 91 97 As you can see, the exact same code produced different results – and that’s exactly what we want! Each time you run rnorm(), or another distribution function, you’ll get a new random sample. 5.3.4.2 Use set.seed() to control random samples There will be cases where you will want to exert some control over the random samples that R produces from sampling functions. For example, you may want to create a reproducible example of some code that anyone else can replicate exactly. To do this, use the set.seed() function. Using set.seed() will force R to produce consistent random samples at any time on any computer. In the code below I’ll set the sampling seed to 100 with set.seed(100). I’ll then run rnorm() twice. The results will always be consistent (because we fixed the sampling seed). # Fix sampling seed to 100, so the next sampling functions # always produce the same values set.seed(100) # The result will always be -0.5022, 0.1315, -0.0789 rnorm(3, mean = 0, sd = 1) ## [1] -0.502 0.132 -0.079 # The result will always be 0.887, 0.117, 0.319 rnorm(3, mean = 0, sd = 1) ## [1] 0.89 0.12 0.32 Try running the same code on your machine and you’ll see the exact same samples that I got above. Oh and the value of 100 I used above in set.seed(100) is totally arbitrary – you can set the seed to any integer you want. I just happen to like how set.seed(100) looks in my code. 5.4 Test your R might! Create the vector [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] in three ways: once using c(), once using a:b, and once using seq(). Create the vector [2.1, 4.1, 6.1, 8.1] in two ways, once using c() and once using seq() Create the vector [0, 5, 10, 15] in 3 ways: using c(), seq() with a by argument, and seq() with a length.out argument. Create the vector [101, 102, 103, 200, 205, 210, 1000, 1100, 1200] using a combination of the c() and seq() functions A new batch of 100 pirates are boarding your ship and need new swords. You have 10 scimitars, 40 broadswords, and 50 cutlasses that you need to distribute evenly to the 100 pirates as they board. Create a vector of length 100 where there is 1 scimitar, 4 broadswords, and 5 cutlasses in each group of 10. That is, in the first 10 elements there should be exactly 1 scimitar, 4 broadswords and 5 cutlasses. The next 10 elements should also have the same number of each sword (and so on). Create a vector that repeats the integers from 1 to 5, 10 times. That is [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …]. The length of the vector should be 50! Now, create the same vector as before, but this time repeat 1, 10 times, then 2, 10 times, etc., That is [1, 1, 1, …, 2, 2, 2, …, … 5, 5, 5]. The length of the vector should also be 50 Create a vector containing 50 samples from a Normal distribution with a population mean of 20 and standard deviation of 2. Create a vector containing 25 samples from a Uniform distribution with a lower bound of -100 and an upper bound of -50. "],
["vectorfunctions.html", "Chapter 6 Vector functions 6.1 Arithmetic operations on vectors 6.2 Summary statistics 6.3 Counting statistics 6.4 Missing (NA) values 6.5 Standardization (z-score) 6.6 Test your R Might!", " Chapter 6 Vector functions In this chapter, we’ll cover the core functions for vector objects. The code below uses the functions you’ll learn to calculate summary statistics from two exams. # 10 students from two different classes took two exams. # Here are three vectors showing the data midterm &lt;- c(62, 68, 75, 79, 55, 62, 89, 76, 45, 67) final &lt;- c(78, 72, 97, 82, 60, 83, 92, 73, 50, 88) # How many students are there? length(midterm) ## [1] 10 # Add 5 to each midterm score (extra credit!) midterm &lt;- midterm + 5 midterm ## [1] 67 73 80 84 60 67 94 81 50 72 # Difference between final and midterm scores final - midterm ## [1] 11 -1 17 -2 0 16 -2 -8 0 16 # Each student&#39;s average score (midterm + final) / 2 ## [1] 72 72 88 83 60 75 93 77 50 80 # Mean midterm grade mean(midterm) ## [1] 73 # Standard deviation of midterm grades sd(midterm) ## [1] 13 # Highest final grade max(final) ## [1] 97 # z-scores midterm.z &lt;- (midterm - mean(midterm)) / sd(midterm) final.z &lt;- (final - mean(final)) / sd(final) 6.1 Arithmetic operations on vectors So far, you know how to do basic arithmetic operations like + (addition), - (subtraction), and * (multiplication) on scalars. Thankfully, R makes it just as easy to do arithmetic operations on numeric vectors: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(10, 20, 30, 40, 50) a + 100 ## [1] 101 102 103 104 105 a + b ## [1] 11 22 33 44 55 (a + b) / 10 ## [1] 1.1 2.2 3.3 4.4 5.5 If you do an operation on a vector with a scalar, R will apply the scalar to each element in the vector. For example, if you have a vector and want to add 10 to each element in the vector, just add the vector and scalar objects. Let’s create a vector with the integers from 1 to 10, and add then add 100 to each element: # Take the integers from 1 to 10, then add 100 to each 1:10 + 100 ## [1] 101 102 103 104 105 106 107 108 109 110 As you can see, the result is [1 + 100, 2 + 100, … 10 + 100]. Of course, we could have made this vector with the a:b function like this: 101:110, but you get the idea. Of course, this doesn’t only work with addition…oh no. Let’s try division, multiplication, and exponents. Let’s create a vector a with the integers from 1 to 10 and then change it up: a &lt;- 1:10 a / 100 ## [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 a ^ 2 ## [1] 1 4 9 16 25 36 49 64 81 100 Again, if you perform an algebraic operation on a vector with a scalar, R will just apply the operation to every element in the vector. 6.1.1 Basic math with multiple vectors What if you want to do some operation on two vectors of the same length? Easy. Just apply the operation to both vectors. R will then combine them element–by–element. For example, if you add the vector [1, 2, 3, 4, 5] to the vector [5, 4, 3, 2, 1], the resulting vector will have the values [1 + 5, 2 + 4, 3 + 3, 4 + 2, 5 + 1] = [6, 6, 6, 6, 6]: c(1, 2, 3, 4, 5) + c(5, 4, 3, 2, 1) ## [1] 6 6 6 6 6 Let’s create two vectors a and b where each vector contains the integers from 1 to 5. We’ll then create two new vectors ab.sum, the sum of the two vectors and ab.diff, the difference of the two vectors, and ab.prod, the product of the two vectors: a &lt;- 1:5 b &lt;- 1:5 ab.sum &lt;- a + b ab.diff &lt;- a - b ab.prod &lt;- a * b ab.sum ## [1] 2 4 6 8 10 ab.diff ## [1] 0 0 0 0 0 ab.prod ## [1] 1 4 9 16 25 6.1.2 Ex: Pirate Bake Sale Let’s say you had a bake sale on your ship where 5 pirates sold both pies and cookies. You could record the total number of pies and cookies sold in two vectors: pies &lt;- c(3, 6, 2, 10, 4) cookies &lt;- c(70, 40, 40, 200, 60) Now, let’s say you want to know how many total items each pirate sold. You can do this by just adding the two vectors: total.sold &lt;- pies + cookies total.sold ## [1] 73 46 42 210 64 Crazy. 6.2 Summary statistics Ok, now that we can create vectors, let’s learn the basic descriptive statistics functions. We’ll start with functions that apply to continuous data. Continuous data is data that, generally speaking, can take on an infinite number of values. Height and weight are good examples of continuous data. Table 6.1 contains common functions for continuous, numeric vectors. Each of them takes a numeric vector as an argument, and returns either a scalar (or in the case of summary(), a table) as a result. Table 6.1: Summary statistic functions for continuous data. Function Example Result sum(x), product(x) sum(1:10) 55 min(x), max(x) min(1:10) 1 mean(x), median(x) mean(1:10) 5.5 sd(x), var(x), range(x) sd(1:10) 3.03 quantile(x, probs) quantile(1:10, probs = .2) 2.8 summary(x) summary(1:10) Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0 Let’s calculate some descriptive statistics from some pirate related data. I’ll create a vector called x that contains the number of tattoos from 10 random pirates. tattoos &lt;- c(4, 50, 2, 39, 4, 20, 4, 8, 10, 100) Now, we can calculate several descriptive statistics on this vector by using the summary statistics functions: min(tattoos) ## [1] 2 mean(tattoos) ## [1] 24 sd(tattoos) ## [1] 31 6.2.1 length() Figure 6.1: According to this article published in 2015 in Plos One, when it comes to people, length may matter for some. But trust me, for vectors it always does. Vectors have one dimension: their length. Later on, when you combine vectors into more higher dimensional objects, like matrices and dataframes, you will need to make sure that all the vectors you combine have the same length. But, when you want to know the length of a vector, don’t stare at your computer screen and count the elements one by one! (That said, I must admit that I still do this sometimes…). Instead, use length() function. The length() function takes a vector as an argument, and returns a scalar representing the number of elements in the vector: a &lt;- 1:10 length(a) # How many elements are in a? ## [1] 10 b &lt;- seq(from = 1, to = 100, length.out = 20) length(b) # How many elements are in b? ## [1] 20 length(c(&quot;This&quot;, &quot;character&quot;, &quot;vector&quot;, &quot;has&quot;, &quot;six&quot;, &quot;elements.&quot;)) ## [1] 6 length(&quot;This character scalar has just one element.&quot;) ## [1] 1 Get used to the length() function people, you’ll be using it a lot! 6.2.2 Additional numeric vector functions Table 6.2 contains additional functions that you will find useful when managing numeric vectors: Table 6.2: Vector summary functions for continuous data. Function Description Example Result round(x, digits) Round elements in x to digits digits round(c(2.231, 3.1415), digits = 1) 2.2, 3.1 ceiling(x), floor(x) Round elements x to the next highest (or lowest) integer ceiling(c(5.1, 7.9)) 6, 8 x %% y Modular arithmetic (ie. x mod y) 7 %% 3 1 6.2.3 Sample statistics from random samples Now that you know how to calculate summary statistics, let’s take a closer look at how R draws random samples using the rnorm() and runif() functions. In the next code chunk, I’ll calculate some summary statistics from a vector of 5 values from a Normal distribution with a mean of 10 and a standard deviation of 5. I’ll then calculate summary statistics from this sample using mean() and sd(): # 5 samples from a Normal dist with mean = 10 and sd = 5 x &lt;- rnorm(n = 5, mean = 10, sd = 5) # What are the mean and standard deviation of the sample? mean(x) ## [1] 11 sd(x) ## [1] 2.5 As you can see, the mean and standard deviation of our sample vector are close to the population values of 10 and 5 – but they aren’t exactly the same because these are sample data. If we take a much larger sample (say, 100,000), the sample statistics should get much closer to the population values: # 100,000 samples from a Normal dist with mean = 10, sd = 5 y &lt;- rnorm(n = 100000, mean = 10, sd = 5) mean(y) ## [1] 10 sd(y) ## [1] 5 Yep, sure enough our new sample y (containing 100,000 values) has a sample mean and standard deviation much closer (almost identical) to the population values than our sample x (containing only 5 values). This is an example of what is called the law of large numbers. Google it. 6.3 Counting statistics Next, we’ll move on to common counting functions for vectors with discrete or non-numeric data. Discrete data are those like gender, occupation, and monkey farts, that only allow for a finite (or at least, plausibly finite) set of responses. Common functions for discrete vectors are in Table 6.3. Each of these vectors takes a vector as an argument – however, unlike the previous functions we looked at, the used as arguments to these functions can be either numeric or character. Table 6.3: Counting functions for discrete data. Function Description Example Result unique(x) Returns a vector of all unique values. unique(c(1, 1, 2, 10)) 1, 2, 10 table(x, exclude) Returns a table showing all the unique values as well as a count of each occurrence. To include a count of NA values, include the argument exclude = NULL table(c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 2-&quot;a&quot;, 1-&quot;b&quot;, 1-&quot;c&quot; Let’s test these functions by starting with two vectors of discrete data: vec &lt;- c(1, 1, 1, 5, 1, 1, 10, 10, 10) gender &lt;- c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;) The function unique(x) will tell you all the unique values in the vector, but won’t tell you anything about how often each value occurs. unique(vec) ## [1] 1 5 10 unique(gender) ## [1] &quot;M&quot; &quot;F&quot; The function table() does the same thing as unique(), but goes a step further in telling you how often each of the unique values occurs: table(vec) ## vec ## 1 5 10 ## 5 1 3 table(gender) ## gender ## F M ## 5 4 If you want to get a table of percentages instead of counts, you can just divide the result of the table() function by the sum of the result: table(vec) / sum(table(vec)) ## vec ## 1 5 10 ## 0.56 0.11 0.33 table(gender) / sum(table(gender)) ## gender ## F M ## 0.56 0.44 6.4 Missing (NA) values In R, missing data are coded as NA. In real datasets, NA values turn up all the time. Unfortunately, most descriptive statistics functions will freak out if there is a missing (NA) value in the data. For example, the following code will return NA as a result because there is an NA value in the data vector: a &lt;- c(1, 5, NA, 2, 10) mean(a) ## [1] NA Thankfully, there’s a way we can work around this. To tell a descriptive statistic function to ignore missing (NA) values, include the argument na.rm = TRUE in the function. This argument explicitly tells the function to ignore NA values. Let’s try calculating the mean of the vector a again, this time with the additionalna.rm = TRUE argument: mean(a, na.rm = TRUE) ## [1] 4.5 Now, the function ignored the NA value and returned the mean of the remaining data. While this may seem trivial now (why did we include an NA value in the vector if we wanted to ignore it?!), it will be become very important when we apply the function to real data which, very often, contains missing values. 6.5 Standardization (z-score) A common task in statistics is to standardize variables – also known as calculating z-scores. The purpose of standardizing a vector is to put it on a common scale which allows you to compare it to other (standardized) variables. To standardize a vector, you simply subtract the vector by its mean, and then divide the result by the vector’s standard deviation. If the concept of z-scores is new to you – don’t worry. In the next worked example, you’ll see how it can help you compare two sets of data. But for now, let’s see how easy it is to standardize a vector using basic arithmetic. Let’s say you have a vector a containing some data. We’ll assign the vector to a new object called a then calculate the mean and standard deviation with the mean() and sd() functions: a &lt;- c(5, 3, 7, 5, 5, 3, 4) mean(a) ## [1] 4.6 sd(a) ## [1] 1.4 Ok. Now we’ll create a new vector called a.z which is a standardized version of a. To do this, we’ll simply subtract the mean of the vector, then divide by the standard deviation. a.z &lt;- (a - mean(a)) / sd(a) Now let’s look at the standardized values: a.z ## [1] 0.31 -1.12 1.74 0.31 0.31 -1.12 -0.41 The mean of a.z should now be 0, and the standard deviation of a.z should now be 1. Let’s make sure: mean(a.z) ## [1] 2e-16 sd(a.z) ## [1] 1 Sweet. Oh, don’t worry that the mean of a.z doesn’t look like exactly zero. Using non-scientific notation, the result is 0.000000000000000198. For all intents and purposes, that’s 0. The reason the result is not exactly 0 is due to computer science theoretical reasons that I cannot explain (because I don’t understand them). 6.5.1 Ex: Evaluating a competition Your gluten-intolerant first mate just perished in a tragic soy sauce incident and it’s time to promote another member of your crew to the newly vacated position. Of course, only two qualities really matter for a pirate: rope-climbing, and grogg drinking. Therefore, to see which of your crew deserves the promotion, you decide to hold a climbing and drinking competition. In the climbing competition, you measure how many feet of rope a pirate can climb in an hour. In the drinking competition, you measure how many mugs of grogg they can drink in a minute. Five pirates volunteer for the competition – here are their results: Table 6.4: Scores from a pirate competition pirate grogg climbing Heidi 12 100 Andrew 8 520 Becki 1 430 Madisen 6 200 David 2 700 We can represent the main results with two vectors grogg and climbing: grogg &lt;- c(12, 8, 1, 6, 2) climbing &lt;- c(100, 520, 430, 200, 700) Now you’ve got the data, but there’s a problem: the scales of the numbers are very different. While the grogg numbers range from 1 to 12, the climbing numbers have a much larger range from 100 to 700. This makes it difficult to compare the two sets of numbers directly. To solve this problem, we’ll use standardization. Let’s create new standardized vectors called grogg.z and climbing.z grogg.z &lt;- (grogg - mean(grogg)) / sd(grogg) climbing.z &lt;- (climbing - mean(climbing)) / sd(climbing) Now let’s look at the final results grogg.z ## [1] 1.379 0.489 -1.068 0.044 -0.845 climbing.z ## [1] -1.20 0.54 0.17 -0.78 1.28 It looks like there were two outstanding performances in particular. In the grogg drinking competition, the first pirate (Heidi) had a z-score of 1.4. We can interpret this by saying that Heidi drank 1.4 more standard deviations of mugs of grogg than the average pirate. In the climbing competition, the fifth pirate (David) had a z-score of 1.3. Here, we would conclude that David climbed 1.3 standard deviations more than the average pirate. But which pirate was the best on average across both events? To answer this, let’s create a combined z-score for each pirate which calculates the average z-scores for each pirate across the two events. We’ll do this by adding two performances and dividing by two. This will tell us, how good, on average, each pirate did relative to her fellow pirates. average.z &lt;- (grogg.z + (climbing.z)) / 2 Let’s look at the result: round(average.z, 1) ## [1] 0.1 0.5 -0.5 -0.4 0.2 The highest average z-score belongs to the second pirate (Andrew) who had an average z-score value of 0.5. The first and last pirates, who did well in one event, seemed to have done poorly in the other event. Moral of the story: promote the pirate who can drink and climb. 6.6 Test your R Might! Create a vector that shows the square root of the integers from 1 to 10. Renata thinks that she finds more treasure when she’s had a mug of grogg than when she doesn’t. To test this, she recorded how much treasure she found over 7 days without drinking any grogg (ie., sober), and then did the same over 7 days while drinking grogg (ie., drunk). Here are her results: Table 6.5: Renata’s treasure haul when she was sober and when she was drunk day sober drunk Monday 2 0 Tuesday 0 0 Wednesday 3 1 Thursday 1 0 Friday 0 1 Saturday 3 2 Sunday 5 2 How much treasure did Renata find on average when she was sober? What about when she was drunk? Using Renata’s data again, create a new vector called difference that shows how much more treasure Renata found when she was drunk and when she was not. What was the mean, median, and standard deviation of the difference? There’s an old parable that goes something like this. A man does some work for a king and needs to be paid. Because the man loves rice (who doesn’t?!), the man offers the king two different ways that he can be paid. You can either pay me 100 kilograms of rice, or, you can pay me as follows: get a chessboard and put one grain of rice in the top left square. Then put 2 grains of rice on the next square, followed by 4 grains on the next, 8 grains on the next…and so on, where the amount of rice doubles on each square, until you get to the last square. When you are finished, give me all the grains of rice that would (in theory), fit on the chessboard. The king, sensing that the man was an idiot for making such a stupid offer, immediately accepts the second option. He summons a chessboard, and begins counting out grains of rice one by one… Assuming that there are 64 squares on a chessboard, calculate how many grains of rice the main will receive. If one grain of rice weights 1/64000 kilograms, how many kilograms of rice did he get? Hint: If you have trouble coming up with the answer, imagine how many grains are on the first, second, third and fourth squares, then try to create the vector that shows the number of grains on each square. Once you come up with that vector, you can easily calculate the final answer with the sum() function. "],
["vectorindexing.html", "Chapter 7 Indexing Vectors with [ ] 7.1 Numerical Indexing 7.2 Logical Indexing 7.3 Changing values of a vector 7.4 Test your R Might!: Movie data", " Chapter 7 Indexing Vectors with [ ] boat.names boat.colors boat.ages boat.prices boat.costs a black 143 53 52 b green 53 87 80 c pink 356 54 20 d blue 23 66 100 e blue 647 264 189 f green 24 32 12 g green 532 532 520 h yellow 43 58 68 i black 66 99 80 j black 86 132 100 # Boat sale. Creating the data vectors boat.names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;) boat.colors &lt;- c(&quot;black&quot;, &quot;green&quot;, &quot;pink&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;) boat.ages &lt;- c(143, 53, 356, 23, 647, 24, 532, 43, 66, 86) boat.prices &lt;- c(53, 87, 54, 66, 264, 32, 532, 58, 99, 132) boat.costs &lt;- c(52, 80, 20, 100, 189, 12, 520, 68, 80, 100) # What was the price of the first boat? boat.prices[1] ## [1] 53 # What were the ages of the first 5 boats? boat.ages[1:5] ## [1] 143 53 356 23 647 # What were the names of the black boats? boat.names[boat.colors == &quot;black&quot;] ## [1] &quot;a&quot; &quot;i&quot; &quot;j&quot; # What were the prices of either green or yellow boats? boat.prices[boat.colors == &quot;green&quot; | boat.colors == &quot;yellow&quot;] ## [1] 87 32 532 58 # Change the price of boat &quot;s&quot; to 100 boat.prices[boat.names == &quot;s&quot;] &lt;- 100 # What was the median price of black boats less than 100 years old? median(boat.prices[boat.colors == &quot;black&quot; &amp; boat.ages &lt; 100]) ## [1] 116 # How many pink boats were there? sum(boat.colors == &quot;pink&quot;) ## [1] 1 # What percent of boats were older than 100 years old? mean(boat.ages &lt; 100) ## [1] 0.6 By now you should be a whiz at applying functions like mean() and table() to vectors. However, in many analyses, you won’t want to calculate statistics of an entire vector. Instead, you will want to access specific subsets of values of a vector based on some criteria. For example, you may want to access values in a specific location in the vector (i.e.; the first 10 elements) or based on some criteria within that vector (i.e.; all values greater than 0), or based on criterion from values in a different vector (e.g.; All values of age where sex is Female). To access specific values of a vector in R, we use indexing using brackets []. In general, whatever you put inside the brackets, tells R which values of the vector object you want. There are two main ways that you can use indexing to access subsets of data in a vector: numerical and logical indexing. 7.1 Numerical Indexing With numerical indexing, you enter a vector of integers corresponding to the values in the vector you want to access in the form a[index], where a is the vector, and index is a vector of index values. For example, let’s use numerical indexing to get values from our boat vectors. # What is the first boat name? boat.names[1] ## [1] &quot;a&quot; # What are the first five boat colors? boat.colors[1:5] ## [1] &quot;black&quot; &quot;green&quot; &quot;pink&quot; &quot;blue&quot; &quot;blue&quot; # What is every second boat age? boat.ages[seq(1, 5, by = 2)] ## [1] 143 356 647 You can use any indexing vector as long as it contains integers. You can even access the same elements multiple times: # What is the first boat age (3 times) boat.ages[c(1, 1, 1)] ## [1] 143 143 143 It it makes your code clearer, you can define an indexing object before doing your actual indexing. For example, let’s define an object called my.index and use this object to index our data vector: my.index &lt;- 3:5 boat.names[my.index] ## [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; 7.2 Logical Indexing Figure 7.1: Logical indexing. Good for R aliens and R pirates. The second way to index vectors is with logical vectors. A logical vector is a vector that only contains TRUE and FALSE values. In R, true values are designated with TRUE, and false values with FALSE. When you index a vector with a logical vector, R will return values of the vector for which the indexing vector is TRUE. If that was confusing, think about it this way: a logical vector, combined with the brackets [ ], acts as a filter for the vector it is indexing. It only lets values of the vector pass through for which the logical vector is TRUE. Figure 7.2: FALSE values in a logical vector are like lots of mini-Gandolfs. In this example, I am indexing a vector x with a logical vector y (y for example could be x &gt; 0, so all positive values of x are TRUE and all negative values are FALSE). The result is a vector of length 2, which are the values of x for which the logical vector y was true. Gandolf stopped all the values of x for which y was FALSE. You could create logical vectors directly using c(). For example, I could access every other value of the following vector as follows: a &lt;- c(1, 2, 3, 4, 5) a[c(TRUE, FALSE, TRUE, FALSE, TRUE)] ## [1] 1 3 5 As you can see, R returns all values of the vector a for which the logical vector is TRUE. Figure 7.3: Logical comparison operators in R However, creating logical vectors using c() is tedious. Instead, it’s better to create logical vectors from existing vectors using comparison operators like &lt; (less than), == (equals to), and != (not equal to). A complete list of the most common comparison operators is in Figure~. For example, let’s create some logical vectors from our boat.ages vector: # Which ages are &gt; 100? boat.ages &gt; 100 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE # Which ages are equal to 23? boat.ages == 23 ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE # Which boat names are equal to c? boat.names == &quot;c&quot; ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE You can also create logical vectors by comparing a vector to another vector of the same length. When you do this, R will compare values in the same position (e.g.; the first values will be compared, then the second values, etc.). For example, we can compare the boat.cost and boat.price vectors to see which boats sold for a higher price than their cost: # Which boats had a higher price than cost? boat.prices &gt; boat.costs ## [1] TRUE TRUE TRUE FALSE TRUE TRUE TRUE FALSE TRUE TRUE # Which boats had a lower price than cost? boat.prices &lt; boat.costs ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE Once you’ve created a logical vector using a comparison operator, you can use it to index any vector with the same length. Here, I’ll use logical vectors to get the prices of boats whose ages were greater than 100: # What were the prices of boats older than 100? boat.prices[boat.ages &gt; 100] ## [1] 53 54 264 532 Here’s how logical indexing works step-by-step: # Which boat prices are greater than 100? boat.ages &gt; 100 ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE # Writing the logical index by hand (you&#39;d never do this!) boat.prices[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE)] ## [1] 53 54 264 532 # Doing it all in one step! You get the same answer boat.prices[boat.ages &gt; 100] ## [1] 53 54 264 532 7.2.1 &amp; (and), | (or), %in% In addition to using single comparison operators, you can combine multiple logical vectors using the OR (which looks like | and AND &amp; commands. The OR | operation will return TRUE if any of the logical vectors is TRUE, while the AND &amp; operation will only return TRUE if all of the values in the logical vectors is TRUE. This is especially powerful when you want to create a logical vector based on criteria from multiple vectors. For example, let’s create a logical vector indicating which boats had a price greater than 200 OR less than 100, and then use that vector to see what the names of these boats were: # Which boats had prices greater than 200 OR less than 100? boat.prices &gt; 200 | boat.prices &lt; 100 ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE # What were the NAMES of these boats boat.names[boat.prices &gt; 200 | boat.prices &lt; 100] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; You can combine as many logical vectors as you want (as long as they all have the same length!): # Boat names of boats with a color of black OR with a price &gt; 100 boat.names[boat.colors == &quot;black&quot; | boat.prices &gt; 100] ## [1] &quot;a&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;j&quot; # Names of blue boats with a price greater than 200 boat.names[boat.colors == &quot;blue&quot; &amp; boat.prices &gt; 200] ## [1] &quot;e&quot; You can combine as many logical vectors as you want to create increasingly complex selection criteria. For example, the following logical vector returns TRUE for cases where the boat colors are black OR brown, AND where the price was less than 100: # Which boats were eithe black or brown, AND had a price less than 100? (boat.colors == &quot;black&quot; | boat.colors == &quot;brown&quot;) &amp; boat.prices &lt; 100 ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE # What were the names of these boats? boat.names[(boat.colors == &quot;black&quot; | boat.colors == &quot;brown&quot;) &amp; boat.prices &lt; 100] ## [1] &quot;a&quot; &quot;i&quot; When using multiple criteria, make sure to use parentheses when appropriate. If I didn’t use parentheses above, I would get a different answer. The %in% operation helps you to easily create multiple OR arguments.Imagine you have a vector of categorical data that can take on many different values. For example, you could have a vector x indicating people’s favorite letters. x &lt;- c(&quot;a&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;, &quot;z&quot;) Now, let’s say you want to create a logical vector indicating which values are either a or b or c or d. You could create this logical vector with multiple | (OR) commands: x == &quot;a&quot; | x == &quot;b&quot; | x == &quot;c&quot; | x == &quot;d&quot; ## [1] TRUE FALSE TRUE TRUE FALSE However, this takes a long time to write. Thankfully, the %in% operation allows you to combine multiple OR comparisons much faster. To use the %in% function, just put it in between the original vector, and a new vector of possible values. The %in% function goes through every value in the vector x, and returns TRUE if it finds it in the vector of possible values – otherwise it returns FALSE. x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ## [1] TRUE FALSE TRUE TRUE FALSE As you can see, the result is identical to our previous result. 7.2.2 Counts and percentages from logical vectors Many (if not all) R functions will interpret TRUE values as 1 and FALSE values as 0. This allows us to easily answer questions like “How many values in a data vector are greater than 0?” or “What percentage of values are equal to 5?” by applying the sum() or mean() function to a logical vector. We’ll start with a vector x of length 10, containing 3 positive numbers and 5 negative numbers. x &lt;- c(1, 2, 3, -5, -5, -5, -5, -5) We can create a logical vector to see which values are greater than 0: x &gt; 0 ## [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE Now, we’ll use sum() and mean() on that logical vector to see how many of the values in x are positive, and what percent are positive. We should find that there are 5 TRUE values, and that 50% of the values (5 / 10) are TRUE. sum(x &gt; 0) ## [1] 3 mean(x &gt; 0) ## [1] 0.38 This is a really powerful tool. Pretty much any time you want to answer a question like “How many of X are Y” or “What percent of X are Y”, you use sum() or mean() function with a logical vector as an argument. 7.2.3 Additional Logical functions R has lots of special functions that take vectors as arguments, and return logical vectors based on multiple criteria. For example, you can use the is.na() function to test which values of a vector are missing. Table 7.1 contains some that I frequently use: Table 7.1: Functions to create and use logical vectors. Function Description Example Result is.na(x) Which values in x are NA? is.na(c(2, NA, 5)) FALSE, TRUE, FALSE is.finite(x) Which values in x are numbers? is.finite(c(NA, 89, 0)) FALSE, TRUE, TRUE duplicated(x) Which values in x are duplicated? duplicated(c(1, 4, 1, 2)) FALSE, FALSE, TRUE, FALSE which(x) Which values in x are TRUE? which(c(TRUE, FALSE, TRUE)) 1, 3 Logical vectors aren’t just good for indexing, you can also use them to figure out which values in a vector satisfy some criteria. To do this, use the function which(). If you apply the function which() to a logical vector, R will tell you which values of the index are TRUE. For example: # A vector of sex information sex &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;) # Which values of sex are m? which(sex == &quot;m&quot;) ## [1] 1 2 4 # Which values of sex are f? which(sex == &quot;f&quot;) ## [1] 3 5 6 7.3 Changing values of a vector Now that you know how to index a vector, you can easily change specific values in a vector using the assignment (&lt;-) operation. To do this, just assign a vector of new values to the indexed values of the original vector: Let’s create a vector a which contains 10 1s: a &lt;- rep(1, 10) Now, let’s change the first 5 values in the vector to 9s by indexing the first five values, and assigning the value of 9: a[1:5] &lt;- 9 a ## [1] 9 9 9 9 9 1 1 1 1 1 Now let’s change the last 5 values to 0s. We’ll index the values 6 through 10, and assign a value of 0. a[6:10] &lt;- 0 a ## [1] 9 9 9 9 9 0 0 0 0 0 Of course, you can also change values of a vector using a logical indexing vector. For example, let’s say you have a vector of numbers that should be from 1 to 10. If values are outside of this range, you want to set them to either the minimum (1) or maximum (10) value: # x is a vector of numbers that should be from 1 to 10 x &lt;- c(5, -5, 7, 4, 11, 5, -2) # Assign values less than 1 to 1 x[x &lt; 1] &lt;- 1 # Assign values greater than 10 to 10 x[x &gt; 10] &lt;- 10 # Print the result! x ## [1] 5 1 7 4 10 5 1 As you can see, our new values of x are now never less than 1 or greater than 10! A note on indexing… Technically, when you assign new values to a vector, you should always assign a vector of the same length as the number of values that you are updating. For example, given a vector a with 10 1s: a &lt;- rep(1, 10) To update the first 5 values with 5 9s, we should assign a new vector of 5 9s a[1:5] &lt;- c(9, 9, 9, 9, 9) a ## [1] 9 9 9 9 9 1 1 1 1 1 However, if we repeat this code but just assign a single 9, R will repeat the value as many times as necessary to fill the indexed value of the vector. That’s why the following code still works: a[1:5] &lt;- 9 a ## [1] 9 9 9 9 9 1 1 1 1 1 In other languages this code wouldn’t work because we’re trying to replace 5 values with just 1. However, this is a case where R bends the rules a bit. 7.3.1 Ex: Fixing invalid responses to a Happiness survey Assigning and indexing is a particularly helpful tool when, for example, you want to remove invalid values in a vector before performing an analysis. For example, let’s say you asked 10 people how happy they were on a scale of 1 to 5 and received the following responses: happy &lt;- c(1, 4, 2, 999, 2, 3, -2, 3, 2, 999) As you can see, we have some invalid values (999 and -2) in this vector. To remove them, we’ll use logical indexing to change the invalid values (999 and -2) to NA. We’ll create a logical vector indicating which values of happy are invalid using the %in% operation. Because we want to see which values are invalid, we’ll add the == FALSE condition (If we don’t, the index will tell us which values are valid). # Which values of happy are NOT in the set 1:5? invalid &lt;- (happy %in% 1:5) == FALSE invalid ## [1] FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE Now that we have a logical index invalid telling us which values are invalid (that is, not in the set 1 through 5), we’ll index happy with invalid, and assign the invalid values as NA: # Convert any invalid values in happy to NA happy[invalid] &lt;- NA happy ## [1] 1 4 2 NA 2 3 NA 3 2 NA We can also recode all the invalid values of happy in one line as follows: # Convert all values of happy that are NOT integers from 1 to 5 to NA happy[(happy %in% 1:5) == FALSE] &lt;- NA As you can see, happy now has NAs for previously invalid values. Now we can take a mean() of the vector and see the mean of the valid responses. # Include na.rm = TRUE to ignore NA values mean(happy, na.rm = TRUE) ## [1] 2.4 7.4 Test your R Might!: Movie data Table 7.2 contains data about 10 of my favorite movies. Table 7.2: Some of my favorite movies movie year boxoffice genre time rating Whatever Works 2009 35.0 Comedy 92 PG-13 It Follows 2015 15.0 Horror 97 R Love and Mercy 2015 15.0 Drama 120 R The Goonies 1985 62.0 Adventure 90 PG Jiro Dreams of Sushi 2012 3.0 Documentary 81 G There Will be Blood 2007 10.0 Drama 158 R Moon 2009 321.0 Science Fiction 97 R Spice World 1988 79.0 Comedy -84 PG-13 Serenity 2005 39.0 Science Fiction 119 PG-13 Finding Vivian Maier 2014 1.5 Documentary 84 Unrated Create new data vectors for each column. What is the name of the 10th movie in the list? What are the genres of the first 4 movies? Some joker put Spice World in the movie names – it should be ``The Naked Gun’’ Please correct the name. What were the names of the movies made before 1990? How many movies were Dramas? What percent of the 10 movies were Dramas? One of the values in the time vector is invalid. Convert any invalid values in this vector to NA. Then, calculate the mean movie time What were the names of the Comedy movies? What were their boxoffice totals? (Two separate questions) What were the names of the movies that made less than $50 Million dollars AND were Comedies? What was the median boxoffice revenue of movies rated either G or PG? What percent of the movies were rated R OR were comedies? "],
["matricesdataframes.html", "Chapter 8 Matrices and Dataframes 8.1 What are matrices and dataframes? 8.2 Creating matrices and dataframes 8.3 Matrix and dataframe functions 8.4 Dataframe column names 8.5 Slicing dataframes 8.6 Combining slicing with functions 8.7 Test your R might! Pirates and superheroes", " Chapter 8 Matrices and Dataframes Figure 8.1: Did you actually think I could talk about matrices without a Matrix reference?! 8.1 What are matrices and dataframes? By now, you should be comfortable with scalar and vector objects. However, you may have noticed that neither object types are appropriate for storing lots of data – such as the results of a survey or experiment. Thankfully, R has two object types that represent large data structures much better: matrices and dataframes. Matrices and dataframes are very similar to spreadsheets in Excel or data files in SPSS. Every matrix or dataframe contains rows (call that number m) and columns (n). Thus, wile a vector has 1 dimension (its length), matrices and dataframes both have 2-dimensions – representing their width and height. You can think of a matrix or dataframe as a combination of n vectors, where each vector has a length of m. Figure 8.2: scalar, Vector, MATRIX While matrices and dataframes look very similar, they aren’t exactly the same. While a matrix can contain either character or numeric columns, a dataframe can contain both numeric and character columns. Because dataframes are more flexible, most real-world datasets, such as surveys containing both numeric (e.g.; age, response times) and character (e.g.; sex, favorite movie) data, will be stored as dataframes in R. WTF – If dataframes are more flexible than matrices, why do we use matrices at all? The answer is that, because they are simpler, matrices take up less computational space than dataframes. Additionally, some functions require matrices as inputs to ensure that they work correctly. In the next section, we’ll cover the most common functions for creating matrix and dataframe objects. We’ll then move on to functions that take matrices and dataframes as inputs. 8.2 Creating matrices and dataframes There are a number of ways to create your own matrix and dataframe objects in R. The most common functions are presented in Table 8.1. Because matrices and dataframes are just combinations of vectors, each function takes one or more vectors as inputs, and returns a matrix or a dataframe. Table 8.1: Functions to create matrices and dataframes. Function Description Example cbind(a, b, c) Combine vectors as columns in a matrix cbind(1:5, 6:10, 11:15) rbind(a, b, c) Combine vectors as rows in a matrix rbind(1:5, 6:10, 11:15) matrix(x, nrow, ncol, byrow) Create a matrix from a vector x matrix(x = 1:12, nrow = 3, ncol = 4) data.frame() Create a dataframe from named columns data.frame(&quot;age&quot; = c(19, 21), sex = c(&quot;m&quot;, &quot;f&quot;)) 8.2.1 cbind(), rbind() cbind() and rbind() both create matrices by combining several vectors of the same length. cbind() combines vectors as columns, while rbind() combines them as rows. Let’s use these functions to create a matrix with the numbers 1 through 30. First, we’ll create three vectors of length 10, then we’ll combine them into one matrix. As you will see, the cbind() function will combine the vectors as columns in the final matrix, while the rbind() function will combine them as rows. x &lt;- 1:5 y &lt;- 6:10 z &lt;- 11:15 # Create a matrix where x, y and z are columns cbind(x, y, z) ## x y z ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 # Create a matrix where x, y and z are rows rbind(x, y, z) ## [,1] [,2] [,3] [,4] [,5] ## x 1 2 3 4 5 ## y 6 7 8 9 10 ## z 11 12 13 14 15 8.2.2 matrix() Remember: Matrices can either contain numbers or character vectors, not both!. If you try to create a matrix with both numbers and characters, it will turn all the numbers into characters: # Creating a matrix with numeric and character columns will make everything a character: cbind(c(1, 2, 3, 4, 5), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) ## [,1] [,2] ## [1,] &quot;1&quot; &quot;a&quot; ## [2,] &quot;2&quot; &quot;b&quot; ## [3,] &quot;3&quot; &quot;c&quot; ## [4,] &quot;4&quot; &quot;d&quot; ## [5,] &quot;5&quot; &quot;e&quot; The matrix() function creates a matrix form a single vector of data. The function has 4 main inputs: data – a vector of data, nrow – the number of rows you want in the matrix, and ncol – the number of columns you want in the matrix, and byrow – a logical value indicating whether you want to fill the matrix by rows. Check out the help menu for the matrix function (`?matrix) to see some additional inputs. Let’s use the matrix() function to re-create a matrix containing the values from 1 to 10. # Create a matrix of the integers 1:10, # with 5 rows and 2 columns matrix(data = 1:10, nrow = 5, ncol = 2) ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 # Now with 2 rows and 5 columns matrix(data = 1:10, nrow = 2, ncol = 5) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 # Now with 2 rows and 5 columns, but fill by row instead of columns matrix(data = 1:10, nrow = 2, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 8.2.3 data.frame() To create a dataframe from vectors, use the data.frame() function. The data.frame() function works very similarly to cbind() – the only difference is that in data.frame() you specify names to each of the columns as you define them. Again, unlike matrices, dataframes can contain both string vectors and numeric vectors within the same object. Because they are more flexible than matrices, most large datasets in R will be stored as dataframes. Let’s create a simple dataframe called survey using the data.frame() function with a mixture of text and numeric columns: # Create a dataframe of survey data survey &lt;- data.frame(&quot;index&quot; = c(1, 2, 3, 4, 5), &quot;sex&quot; = c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;), &quot;age&quot; = c(99, 46, 23, 54, 23)) survey ## index sex age ## 1 1 m 99 ## 2 2 m 46 ## 3 3 m 23 ## 4 4 f 54 ## 5 5 f 23 8.2.3.1 stringsAsFactors = FALSE There is one key argument to data.frame() and similar functions called stringsAsFactors. By default, the data.frame() function will automatically convert any string columns to a specific type of object called a factor in R. A factor is nominal variable that has a well-specified possible set of values that it can take on. For example, one can create a factor sex that can only take on the values &quot;male&quot; and &quot;female&quot;. However, as I’m sure you’re discover, having R automatically convert your string data to factors can lead to lots of strange results. For example: if you have a factor of sex data, but then you want to add a new value called other, R will yell at you and return an error. I hate, hate, HATE when this happens. While there are very, very rare cases when I find factors useful, I almost always don’t want or need them. For this reason, I avoid them at all costs. To tell R to not convert your string columns to factors, you need to include the argument stringsAsFactors = FALSE when using functions such as data.frame() For example, let’s look at the classes of the columns in the dataframe survey that we just created using the str() function (we’ll go over this function in section XXX) # Show me the structure of the survey dataframe str(survey) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ index: num 1 2 3 4 5 ## $ sex : Factor w/ 2 levels &quot;f&quot;,&quot;m&quot;: 2 2 2 1 1 ## $ age : num 99 46 23 54 23 AAAAA!!! R has converted the column sex to a factor with only two possible levels! This can cause major problems later! Let’s create the dataframe again using the argument stringsAsFactors = FALSE to make sure that this doesn’t happen: # Create a dataframe of survey data WITHOUT factors survey &lt;- data.frame(&quot;index&quot; = c(1, 2, 3, 4, 5), &quot;sex&quot; = c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;), &quot;age&quot; = c(99, 46, 23, 54, 23), stringsAsFactors = FALSE) Now let’s look at the new version and make sure there are no factors: # Print the result (it looks the same as before) survey ## index sex age ## 1 1 m 99 ## 2 2 m 46 ## 3 3 m 23 ## 4 4 f 54 ## 5 5 f 23 # Look at the structure: no more factors! str(survey) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ index: num 1 2 3 4 5 ## $ sex : chr &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;f&quot; ... ## $ age : num 99 46 23 54 23 8.2.4 Dataframes pre-loaded in R Now you know how to use functions like cbind() and data.frame() to manually create your own matrices and dataframes in R. However, for demonstration purposes, it’s frequently easier to use existing dataframes rather than always having to create your own. Thankfully, R has us covered: R has several datasets that come pre-installed in a package called datasets – you don’t need to install this package, it’s included in the base R software. While you probably won’t make any major scientific discoveries with these datasets, they allow all R users to test and compare code on the same sets of data. To see a complete list of all the datasets included in the datasets package, run the code: library(help = &quot;datasets&quot;). Table 8.2 shows a few datasets that we will be using in future examples: Table 8.2: A few datasets you can access in R. Dataset Description Rows Columns ChickWeight Experiment on the effect of diet on early growth of chicks. 578 4 InsectSprays The counts of insects in agricultural experimental units treated with different insecticides. 72 2 ToothGrowth Length of odontoblasts (cells responsible for tooth growth) in 60 guinea pigs. 60 3 PlantGrowth Results from an experiment to compare yields (as measured by dried weight of plants) obtained under a control and two different treatment conditions. 30 2 8.3 Matrix and dataframe functions R has lots of functions for viewing matrices and dataframes and returning information about them. Table 8.3 shows some of the most common: Table 8.3: Important functions for understanding matrices and dataframes. Function Description head(x), tail(x) Print the first few rows (or last few rows). View(x) Open the entire object in a new window nrow(x), ncol(x), dim(x) Count the number of rows and columns rownames(), colnames(), names() Show the row (or column) names str(x), summary(x) Show the structure of the dataframe (ie., dimensions and classes) and summary statistics 8.3.1 head(), tail(), View() To see the first few rows of a dataframe, use head(), to see the last few rows, use tail() # head() shows the first few rows head(ChickWeight) ## weight Time Chick Diet ## 1 42 0 1 1 ## 2 51 2 1 1 ## 3 59 4 1 1 ## 4 64 6 1 1 ## 5 76 8 1 1 ## 6 93 10 1 1 # tail() shows he last few rows tail(ChickWeight) ## weight Time Chick Diet ## 573 155 12 50 4 ## 574 175 14 50 4 ## 575 205 16 50 4 ## 576 234 18 50 4 ## 577 264 20 50 4 ## 578 264 21 50 4 To see an entire dataframe in a separate window that looks like spreadsheet, use View() # View() opens the entire dataframe in a new window View(ChickWeight) When you run View(), you’ll see a new window like the one in Figure 8.3 Figure 8.3: Screenshot of the window from View(ChickWeight). You can use this window to visually sort and filter the data to get an idea of how it looks, but you can’t add or remove data and nothing you do will actually change the dataframe. 8.3.2 summary(), str() To get summary statistics on all columns in a dataframe, use the summary() function: # Print summary statistics of ToothGrowth to the console summary(ToothGrowth) ## len supp dose len.cm index ## Min. : 4 OJ:30 Min. :0.50 Min. :0.4 Min. : 1 ## 1st Qu.:13 VC:30 1st Qu.:0.50 1st Qu.:1.3 1st Qu.:16 ## Median :19 Median :1.00 Median :1.9 Median :30 ## Mean :19 Mean :1.17 Mean :1.9 Mean :30 ## 3rd Qu.:25 3rd Qu.:2.00 3rd Qu.:2.5 3rd Qu.:45 ## Max. :34 Max. :2.00 Max. :3.4 Max. :60 To learn about the classes of columns in a dataframe, in addition to some other summary information, use the str() (structure) function. This function returns information for more advanced R users, so don’t worry if the output looks confusing. # Print additional information about ToothGrowth to the console str(ToothGrowth) ## &#39;data.frame&#39;: 60 obs. of 5 variables: ## $ len : num 4.2 11.5 7.3 5.8 6.4 10 11.2 11.2 5.2 7 ... ## $ supp : Factor w/ 2 levels &quot;OJ&quot;,&quot;VC&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ dose : num 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ... ## $ len.cm: num 0.42 1.15 0.73 0.58 0.64 1 1.12 1.12 0.52 0.7 ... ## $ index : int 1 2 3 4 5 6 7 8 9 10 ... Here, we can see that ToothGrowth is a dataframe with 60 observations (ie., rows) and 3 variables (ie., columns). We can also see that the column names are len, supp, and dose 8.4 Dataframe column names One of the nice things about dataframes is that each column will have a name. You can use these name to access specific columns by name without having to know which column number it is. To access the names of a dataframe, use the function names(). This will return a string vector with the names of the dataframe. Let’s use names() to get the names of the ToothGrowth dataframe: # What are the names of columns in the ToothGrowth dataframe? names(ToothGrowth) ## [1] &quot;len&quot; &quot;supp&quot; &quot;dose&quot; &quot;len.cm&quot; &quot;index&quot; To access a specific column in a dataframe by name, you use the $ operator in the form df$name where df is the name of the dataframe, and name is the name of the column you are interested in. This operation will then return the column you want as a vector. Let’s use the $ operator to get a vector of just the length column (called len) from the ToothGrowth dataframe: # Return the len column of ToothGrowth ToothGrowth$len ## [1] 4.2 11.5 7.3 5.8 6.4 10.0 11.2 11.2 5.2 7.0 16.5 16.5 15.2 17.3 ## [15] 22.5 17.3 13.6 14.5 18.8 15.5 23.6 18.5 33.9 25.5 26.4 32.5 26.7 21.5 ## [29] 23.3 29.5 15.2 21.5 17.6 9.7 14.5 10.0 8.2 9.4 16.5 9.7 19.7 23.3 ## [43] 23.6 26.4 20.0 25.2 25.8 21.2 14.5 27.3 25.5 26.4 22.4 24.5 24.8 30.9 ## [57] 26.4 27.3 29.4 23.0 Because the $ operator returns a vector, you can easily calculate descriptive statistics on columns of a dataframe by applying your favorite vector function (like mean() or table()) to a column using $. Let’s calculate the mean tooth length with mean(), and the frequency of each supplement with table(): # What is the mean of the len column of ToothGrowth? mean(ToothGrowth$len) ## [1] 19 # Give me a table of the supp column of ToothGrowth. table(ToothGrowth$supp) ## ## OJ VC ## 30 30 If you want to access several columns by name, you can forgo the $ operator, and put a character vector of column names in brackets: # Give me the len AND supp columns of ToothGrowth head(ToothGrowth[c(&quot;len&quot;, &quot;supp&quot;)]) ## len supp ## 1 4.2 VC ## 2 11.5 VC ## 3 7.3 VC ## 4 5.8 VC ## 5 6.4 VC ## 6 10.0 VC 8.4.1 Adding new columns You can add new columns to a dataframe using the $ and assignment &lt;- operators. To do this, just use the df$name notation and assign a new vector of data to it. For example, let’s create a dataframe called survey with two columns: index and age: # Create a new dataframe called survey survey &lt;- data.frame(&quot;index&quot; = c(1, 2, 3, 4, 5), &quot;age&quot; = c(24, 25, 42, 56, 22)) survey ## index age ## 1 1 24 ## 2 2 25 ## 3 3 42 ## 4 4 56 ## 5 5 22 Now, let’s add a new column called sex with a vector of sex data: # Add a new column called sex to survey survey$sex &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;) Here’s the result # survey with new sex column survey ## index age sex ## 1 1 24 m ## 2 2 25 m ## 3 3 42 f ## 4 4 56 f ## 5 5 22 m As you can see, survey has a new column with the name sex with the values we specified earlier. 8.4.2 Changing column names To change the name of a column in a dataframe, just use a combination of the names() function, indexing, and reassignment. # Change name of 1st column of df to &quot;a&quot; names(df)[1] &lt;- &quot;a&quot; # Change name of 2nd column of df to &quot;b&quot; names(df)[2] &lt;- &quot;b&quot; For example, let’s change the name of the first column of survey from index to participant.number # Change the name of the first column of survey to &quot;participant.number&quot; names(survey)[1] &lt;- &quot;participant.number&quot; survey ## participant.number age sex ## 1 1 24 m ## 2 2 25 m ## 3 3 42 f ## 4 4 56 f ## 5 5 22 m Warning!!!: Change column names with logical indexing to avoid errors! Now, there is one major potential problem with my method above – I had to manually enter the value of 1. But what if the column I want to change isn’t in the first column (either because I typed it wrong or because the order of the columns changed)? This could lead to serious problems later on. To avoid these issues, it’s better to change column names using a logical vector using the format names(df)[names(df) == &quot;old.name&quot;] &lt;- &quot;new.name&quot;. Here’s how to read this: “Change the names of df, but only where the original name was &quot;old.name&quot;, to &quot;new.name&quot;. Let’s use logical indexing to change the name of the column survey$age to survey$years: # Change the column name from age to age.years names(survey)[names(survey) == &quot;age&quot;] &lt;- &quot;years&quot; survey ## participant.number years sex ## 1 1 24 m ## 2 2 25 m ## 3 3 42 f ## 4 4 56 f ## 5 5 22 m 8.5 Slicing dataframes Once you have a dataset stored as a matrix or dataframe in R, you’ll want to start accessing specific parts of the data based on some criteria. For example, if your dataset contains the result of an experiment comparing different experimental groups, you’ll want to calculate statistics for each experimental group separately. The process of selecting specific rows and columns of data based on some criteria is commonly known as slicing. Figure 8.4: Slicing and dicing data. The turnip represents your data, and the knife represents indexing with brackets, or subsetting functions like subset(). The red-eyed clown holding the knife is just off camera. 8.5.1 Slicing with [, ] Just like vectors, you can access specific data in dataframes using brackets. But now, instead of just using one indexing vector, we use two indexing vectors: one for the rows and one for the columns. To do this, use the notation data[rows, columns], where rows and columns are vectors of integers. # Return row 1 df[1, ] # Return column 5 df[, 5] # Rows 1:5 and column 2 df[1:5, 2] Figure 8.5: Ah the ToothGrowth dataframe. Yes, one of the dataframes stored in R contains data from an experiment testing the effectiveness of different doses of Vitamin C supplements on the growth of guinea pig teeth. The images I found by Googling ``guinea pig teeth’’ were all pretty horrifying, so let’s just go with this one. Table 8.4: First few rows of the ToothGrowth dataframe. len supp dose len.cm index 4.2 VC 0.5 0.42 1 11.5 VC 0.5 1.15 2 7.3 VC 0.5 0.73 3 5.8 VC 0.5 0.58 4 6.4 VC 0.5 0.64 5 10.0 VC 0.5 1.00 6 Let’s try indexing the ToothGrowth dataframe. Again, the ToothGrowth dataframe represents the results of a study testing the effectiveness of different types of supplements on the length of guinea pig’s teeth. First, let’s look at the entries in rows 1 through 5, and column 1: # Give me the rows 1-6 and column 1 of ToothGrowth ToothGrowth[1:6, 1] ## [1] 4.2 11.5 7.3 5.8 6.4 10.0 Because the first column is len, the primary dependent measure, this means that the tooth lengths in the first 5 observations are 4.2, 11.5, 7.3, 5.8, 6.4, 10. Of course, you can index matrices and dataframes with longer vectors to get more data. Now, let’s look at the first 3 rows of columns 1 and 3: # Give me rows 1-3 and columns 1 and 3 of ToothGrowth ToothGrowth[1:3, c(1,3)] ## len dose ## 1 4.2 0.5 ## 2 11.5 0.5 ## 3 7.3 0.5 If you want to look at an entire row or an entire column of a matrix or dataframe, you can leave the corresponding index blank. For example, to see the entire 1st row of the ToothGrowth dataframe, we can set the row index to 1, and leave the column index blank: # Give me the 1st row (and all columns) of ToothGrowth ToothGrowth[1, ] ## len supp dose len.cm index ## 1 4.2 VC 0.5 0.42 1 Similarly, to get the entire 2nd column, set the column index to 2 and leave the row index blank: # Give me the 2nd column (and all rows) of ToothGrowth ToothGrowth[, 2] ## [1] VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC VC ## [24] VC VC VC VC VC VC VC OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ ## [47] OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ OJ ## Levels: OJ VC Many, if not all, of the analyses you will be doing will be on subsets of data, rather than entire datasets. For example, if you have data from an experiment, you may wish to calculate the mean of participants in one group separately from another. To do this, we’ll use subsetting – selecting subsets of data based on some criteria. To do this, we can use one of two methods: indexing with logical vectors, or the subset() function. We’ll start with logical indexing first. 8.5.2 Slicing with logical vectors Indexing dataframes with logical vectors is almost identical to indexing single vectors. First, we create a logical vector containing only TRUE and FALSE values. Next, we index a dataframe (typically the rows) using the logical vector to return only values for which the logical vector is TRUE. For example, to create a new dataframe called ToothGrowth.VC containing only data from the guinea pigs who were given the VC supplement, we’d run the following code: # Create a new df with only the rows of ToothGrowth # where supp equals VC ToothGrowth.VC &lt;- ToothGrowth[ToothGrowth$supp == &quot;VC&quot;, ] Of course, just like we did with vectors, we can make logical vectors based on multiple criteria – and then index a dataframe based on those criteria. For example, let’s create a dataframe called ToothGrowth.OJ.a that contains data from the guinea pigs who were given an OJ supplement with a dose less than 1.0: # Create a new df with only the rows of ToothGrowth # where supp equals OJ and dose &lt; 1 ToothGrowth.VC.a &lt;- ToothGrowth[ToothGrowth$supp == &quot;OJ&quot; &amp; ToothGrowth$dose &lt; 1, ] Indexing with brackets is the standard way to slice and dice dataframes. However, the code can get a bit messy. A more elegant method is to use the subset() function. 8.5.3 Slicing with subset() Figure 8.6: The subset() function is like a lightsaber. An elegant function from a more civilized age. The subset() function is one of the most useful data management functions in R. It allows you to slice and dice datasets just like you would with brackets, but the code is much easier to write: Table 8.5 shows the main arguments to the subset() function: Table 8.5: Main arguments for the subset() function. Argument Description x A dataframe you want to subset subset A logical vector indicating the rows to keep select The columns you want to keep Let’s use the subset() function to create a new, subsetted dataset from the ToothGrowth dataframe containing data from guinea pigs who had a tooth length less than 20cm (len &lt; 20), given the OJ supplement (supp == &quot;OJ&quot;), and with a dose greater than or equal to 1 (dose &gt;= 1): # Get rows of ToothGrowth where len &lt; 20 AND supp == &quot;OJ&quot; AND dose &gt;= 1 subset(x = ToothGrowth, subset = len &lt; 20 &amp; supp == &quot;OJ&quot; &amp; dose &gt;= 1) ## len supp dose len.cm index ## 41 20 OJ 1 2.0 41 ## 49 14 OJ 1 1.4 49 As you can see, there were only two cases that satisfied all 3 of our selection criteria. In the example above, I didn’t specify an input to the select argument because I wanted all columns. However, if you just want certain columns, you can just name the columns you want in the select argument: # Get rows of ToothGrowth where len &gt; 30 AND supp == &quot;VC&quot;, but only return the len and index columns subset(x = ToothGrowth, subset = len &gt; 30 &amp; supp == &quot;VC&quot;, select = c(len, index)) ## len index ## 23 34 23 ## 26 32 26 8.6 Combining slicing with functions Now that you know how to slice and dice dataframes using indexing and subset(), you can easily combine slicing and dicing with statistical functions to calculate summary statistics on groups of data. For example, the following code will calculate the mean tooth length of guinea pigs with the OJ supplement using the subset() function: # What is the mean tooth length of Guinea pigs given OJ? # Step 1: Create a subsettted dataframe called oj oj &lt;- subset(x = ToothGrowth, subset = supp == &quot;OJ&quot;) # Step 2: Calculate the mean of the len column from # the new subsetted dataset mean(oj$len) ## [1] 21 We can also get the same solution using logical indexing: # Step 1: Create a subsettted dataframe called oj oj &lt;- ToothGrowth[ToothGrowth$supp == &quot;OJ&quot;,] # Step 2: Calculate the mean of the len column from # the new subsetted dataset mean(oj$len) ## [1] 21 Or heck, we can do it all in one line by only referring to column vectors: mean(ToothGrowth$len[ToothGrowth$supp == &quot;OJ&quot;]) ## [1] 21 As you can see, R allows for many methods to accomplish the same task. The choice is up to you. 8.6.1 with() The with() function helps to save you some typing when you are using multiple columns from a dataframe. Specifically, it allows you to specify a dataframe (or any other object in R) once at the beginning of a line – then, for every object you refer to in the code in that line, R will assume you’re referring to that object in an expression. For example, let’s create a dataframe called health with some health information: health &lt;- data.frame(&quot;age&quot; = c(32, 24, 43, 19, 43), &quot;height&quot; = c(1.75, 1.65, 1.50, 1.92, 1.80), &quot;weight&quot; = c(70, 65, 62, 79, 85)) health ## age height weight ## 1 32 1.8 70 ## 2 24 1.6 65 ## 3 43 1.5 62 ## 4 19 1.9 79 ## 5 43 1.8 85 Now let’s say we want to add a new column called bmi which represents a person’s body mass index. The formula for bmi is \\(bmi = \\frac{height}{weight^{2}} \\times 703\\). If we wanted to calculate the bmi of each person, we’d need to write health$height / health$weight ^ 2: # Calculate bmi health$weight / health$height ^ 2 ## [1] 23 24 28 21 26 As you can see, we have to retype the name of the dataframe for each column. However, using the with() function, we can make it a bit easier by saying the name of the dataframe once. # Save typing by using with() with(health, weight / height ^ 2) ## [1] 23 24 28 21 26 As you can see, the results are identical. In this case, we didn’t save so much typing. But if you are doing many calculations, then with() can save you a lot of typing. For example, contrast these two lines of code that perform identical calculations: # Long code health$weight + health$height / health$age + 2 * health$height ## [1] 74 68 65 83 89 # Short code that does the same thing with(health, weight + height / age + 2 * height) ## [1] 74 68 65 83 89 8.7 Test your R might! Pirates and superheroes Figure 8.7: This is a lesser-known superhero named Maggott who could ‘transform his body to get superhuman strength and endurance, but to do so he needed to release two huge parasitic worms from his stomach cavity and have them eat things’ (http://heavy.com/comedy/2010/04/the-20-worst-superheroes/). Yeah…I’m shocked this guy wasn’t a hit. The following table shows the results of a survey of 10 pirates. In addition to some basic demographic information, the survey asked each pirate “What is your favorite superhero?”&quot; and “How many tattoos do you have?”&quot; Name Sex Age Superhero Tattoos Astrid F 30 Batman 11 Lea F 25 Superman 15 Sarina F 25 Batman 12 Remon M 29 Spiderman 5 Letizia F 22 Batman 65 Babice F 22 Antman 3 Jonas M 35 Batman 9 Wendy F 19 Superman 13 Niveditha F 32 Maggott 900 Gioia F 21 Superman 0 Combine the data into a single dataframe. Complete all the following exercises from the dataframe! What is the median age of the 10 pirates? What was the mean age of female and male pirates separately? What was the most number of tattoos owned by a male pirate? What percent of pirates under the age of 32 were female? What percent of female pirates are under the age of 32? Add a new column to the dataframe called tattoos.per.year which shows how many tattoos each pirate has for each year in their life. Which pirate had the most number of tattoos per year? What are the names of the female pirates whose favorite superhero is Superman? What was the median number of tattoos of pirates over the age of 20 whose favorite superhero is Spiderman? "],
["importingdata.html", "Chapter 9 Importing, saving and managing data 9.1 Workspace management functions 9.2 The working directory 9.3 Projects in RStudio 9.4 The workspace 9.5 .RData files 9.6 .txt files 9.7 Excel, SPSS, and other data files 9.8 Additional tips 9.9 Test your R Might!", " Chapter 9 Importing, saving and managing data Figure 9.1: Your workspace – all the objects, functions, and delicious glue you’ve defined in your current session. Remember way back in Chapter 2 (you know…back when we first met…we were so young and full of excitement then…sorry, now I’m getting emotional…let’s move on… ) when I said everything in R is an object? Well, that’s still true. In this chapter, we’ll cover the basics of R object management. We’ll cover how to load new objects like external datasets into R, how to manage the objects that you already have, and how to export objects from R into external files that you can share with other people or store for your own future use. 9.1 Workspace management functions Here are some functions helpful for managing your workspace that we’ll go over in this chapter: Table 9.1: Functions for managing your workspace, working directory, and writing data from R as .txt or .RData files, and reading files into R Code Description ls() Display all objects in the current workspace rm(a, b, ..) Removes the objects a, b… from your workspace rm(list = ls()) Removes all objects in your workspace getwd() Returns the current working directory setwd(file = &quot;dir) Changes the working directory to a specified file location list.files() Returns the names of all files in the working directory write.table(x, file = &quot;mydata.txt&quot;, sep) writes the object x to a text file called mydata.txt. Define how the columns will be separated with sep (e.g.; sep = &quot;,&quot; for a comma–separated file, and sep = \\t&quot; for a tab–separated file). save(a, b, .., file = &quot;myimage.RData) Saves objects a, b, … to myimage.RData save.image(file = &quot;myimage.RData&quot;) Saves all objects in your workspace to myimage.RData load(file = &quot;myimage.RData&quot;) Loads objects in the file myimage.RData read.table(file = &quot;mydata.txt&quot;, sep, header) Reads a text file called mydata.txt, define how columns are separated with sep (e.g. sep = &quot;,&quot; for comma-delimited files, and sep = &quot;\\t&quot; for tab-delimited files), and whether there is a header column with header = TRUE 9.1.1 Why object and file management is so important Figure 9.2: Your computer is probably so full of selfies like this that if you don’t get organized, you may try to load this into your R session instead of your data file. Your computer is a maze of folders, files, and selfies (see Figure 9.2). Outside of R, when you want to open a specific file, you probably open up an explorer window that allows you to visually search through the folders on your computer. Or, maybe you select recent files, or type the name of the file in a search box to let your computer do the searching for you. While this system usually works for non-programming tasks, it is a no-go for R. Why? Well, the main problem is that all of these methods require you to visually scan your folders and move your mouse to select folders and files that match what you are looking for. When you are programming in R, you need to specify all steps in your analyses in a way that can be easily replicated by others and your future self. This means you can’t just say: “Find this one file I emailed to myself a week ago” or “Look for a file that looks something like experimentAversion3.txt.” Instead, need to be able to write R code that tells R exactly where to find critical files – either on your computer or on the web. To make this job easier, R uses working directories. 9.2 The working directory Figure 9.3: A working directory is like a flag on your computer that tells R where to start looking for your files related to a specific project. Each project should have its own folder with organized sub-folders. The working directory is just a file path on your computer that sets the default location of any files you read into R, or save out of R. In other words, a working directory is like a little flag somewhere on your computer which is tied to a specific analysis project. If you ask R to import a dataset from a text file, or save a dataframe as a text file, it will assume that the file is inside of your working directory. You can only have one working directory active at any given time. The active working directory is called your current working directory. To see your current working directory, use getwd(): # Print my current working directory getwd() ## [1] &quot;/Users/nphillips/Dropbox/manuscripts/YaRrr_bd&quot; As you can see, when I run this code, it tells me that my working directory is in a folder on my Desktop called yarrr. This means that when I try to read new files into R, or write files out of R, it will assume that I want to put them in this folder. If you want to change your working directory, use the setwd() function. For example, if I wanted to change my working directory to an existing Dropbox folder called yarrr, I’d run the following code: # Change my working directory to the following path setwd(dir = &quot;/Users/nphillips/Dropbox/yarrr&quot;) 9.3 Projects in RStudio If you’re using RStudio, you have the option of creating a new R project. A project is simply a working directory designated with a .RProj file. When you open a project (using File/Open Project in RStudio or by double–clicking on the .Rproj file outside of R), the working directory will automatically be set to the directory that the .RProj file is located in. I recommend creating a new R Project whenever you are starting a new research project. Once you’ve created a new R project, you should immediately create folders in the directory which will contain your R code, data files, notes, and other material relevant to your project (you can do this outside of R on your computer, or in the Files window of RStudio). For example, you could create a folder called R that contains all of your R code, a folder called data that contains all your data (etc.). In Figure~9.4 you can see how my working directory looks for a project I am working on called ForensicFFT. Figure 9.4: Here is the folder structure I use for the working directory in my R project called ForensicFFT. As you can see, it contains an .Rproj file generated by RStudio which sets this folder as the working directory. I also created a folder called r for R code, a folder called data for.txt and .RData files) among others. 9.4 The workspace The workspace (aka your working environment) represents all of the objects and functions you have either defined in the current session, or have loaded from a previous session. When you started RStudio for the first time, the working environment was empty because you hadn’t created any new objects or functions. However, as you defined new objects and functions using the assignment operator &lt;-, these new objects were stored in your working environment. When you closed RStudio after defining new objects, you likely got a message asking you “Save workspace image…?”&quot; This is RStudio’s way of asking you if you want to save all the objects currently defined in your workspace as an image file on your computer. 9.4.1 ls() If you want to see all the objects defined in your current workspace, use the ls() function. # Print all the objects in my workspace ls() When I run ls() I received the following result: ## [1] &quot;study1.df&quot; &quot;study2.df&quot; &quot;lm.study1&quot; &quot;lm.study2&quot; &quot;bf.study1&quot; The result above says that I have these 5 objects in my workspace. If I try to refer to an object not listed here, R will return an error. For example, if I try to print study3.df (which isn’t in my workspace), I will receive the following error: # Try to print study3.df # Error because study3.df is NOT in my current workspace study3.df Error: object ‘study3.df’ not found If you receive this error, it’s because the object you are referring to is not in your current workspace. 99% of the time, this happens because you mistyped the name of an object. 9.5 .RData files The best way to store objects from R is with .RData files. .RData files are specific to R and can store as many objects as you’d like within a single file. Think about that. If you are conducting an analysis with 10 different dataframes and 5 hypothesis tests, you can save all of those objects in a single file called ExperimentResults.RData. 9.5.1 save() To save selected objects into one .RData file, use the save() function. When you run the save() function with specific objects as arguments, (like save(a, b, c, file = &quot;myobjects.RData&quot;) all of those objects will be saved in a single file called myobjects.RData Figure 9.5: Saving multiple objects into a single .RData file. For example, let’s create a few objects corresponding to a study. # Create some objects that we&#39;ll save later study1.df &lt;- data.frame(id = 1:5, sex = c(&quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;), score = c(51, 20, 67, 52, 42)) score.by.sex &lt;- aggregate(score ~ sex, FUN = mean, data = study1.df) study1.htest &lt;- t.test(score ~ sex, data = study1.df) Now that we’ve done all of this work, we want to save all three objects in an a file called study1.RData in the data folder of my current working directory. To do this, you can run the following # Save two objects as a new .RData file # in the data folder of my current working directory save(study1.df, score.by.sex, study1.htest, file = &quot;data/study1.RData&quot;) Figure 9.6: Our new study1.RData file is like a van filled with our objects. Once you do this, you should see the study1.RData file in the data folder of your working directory. This file now contains all of your objects that you can easily access later using the load() function (we’ll go over this in a second…). 9.5.2 save.image() If you have many objects that you want to save, then using save can be tedious as you’d have to type the name of every object. To save all the objects in your workspace as a .RData file, use the save.image() function. For example, to save my workspace in the data folder located in my working directory, I’d run the following: # Save my workspace to complete_image.RData in th,e # data folder of my working directory save.image(file = &quot;data/projectimage.RData&quot;) Now, the projectimage.RData file contains all objects in your current workspace. 9.5.3 load() To load an .RData file, that is, to import all of the objects contained in the .RData file into your current workspace, use the load() function. For example, to load the three specific objects that I saved earlier (study1.df, score.by.sex, and study1.htest) in study1.RData, I’d run the following: # Load objects in study1.RData into my workspace load(file = &quot;data/study1.RData&quot;) To load all of the objects in the workspace that I just saved to the data folder in my working directory in projectimage.RData, I’d run the following: # Load objects in projectimage.RData into my workspace load(file = &quot;data/projectimage.RData&quot;) I hope you realize how awesome loading .RData files is. With R, you can store all of your objects, from dataframes to hypothesis tests, in a single .RData file. And then load them into any R session at any time using load(). 9.5.4 rm() To remove objects from your workspace, use the rm() function. Why would you want to remove objects? At some points in your analyses, you may find that your workspace is filled up with one or more objects that you don’t need – either because they’re slowing down your computer, or because they’re just distracting. To remove specific objects, enter the objects as arguments to rm(). For example, to remove a huge dataframe called huge.df, I’d run the following; # Remove huge.df from workspace rm(huge.df) If you want to remove all of the objects in your working directory, enter the argument list = ls() # Remove ALL objects from workspace rm(list = ls()) Important!!! Once you remove an object, you cannot get it back without running the code that originally generated the object! That is, you can’t simply click ‘Undo’ to get an object back. Thankfully, if your R code is complete and well-documented, you should easily be able to either re-create a lost object (e.g.; the results of a regression analysis), or re-load it from an external file. 9.6 .txt files While .RData files are great for saving R objects, sometimes you’ll want to export data (usually dataframes) as a simple .txt text file that other programs, like Excel and Shitty Piece of Shitty Shit, can also read. To do this, use the write.table() function. 9.6.1 write.table() Table 9.2: Arguments for the write.table() function that will save an object x (usually a data frame) as a .txt file. Argument Description x The object you want to write to a text file, usually a dataframe file The document’s file path relative to the working directory unless specified otherwise. For example file = &quot;mydata.txt&quot; saves the text file directly in the working directory, while file = &quot;data/mydata.txt&quot; will save the data in an existing folder called data inside the working directory.You can also specify a full file path outside of your working directory (file = &quot;/Users/CaptainJack/Desktop/OctoberStudy/mydata.txt&quot;) sep A string indicating how the columns are separated. For comma separated files, use sep = &quot;,&quot;, for tab–delimited files, use sep = &quot;\\t&quot; row.names A logical value (TRUE or FALSE) indicating whether or not save the rownames in the text file. (row.names = FALSE will not include row names) For example, the following code will save the pirates dataframe as a tab–delimited text file called pirates.txt in my working directory: # Write the pirates dataframe object to a tab-delimited # text file called pirates.txt in my working directory write.table(x = pirates, file = &quot;pirates.txt&quot;, # Save the file as pirates.txt sep = &quot;\\t&quot;) # Make the columns tab-delimited If you want to save a file to a location outside of your working directory, just use the entire directory name. When you enter a long path name into the file argument of write.table(), R will look for that directory outside of your working directory. For example, to save a text file to my Desktop (which is outside of my working directory), I would set file = &quot;Users/nphillips/Desktop/pirates.txt&quot;. # Write the pirates dataframe object to a tab-delimited # text file called pirates.txt to my desktop write.table(x = pirates, file = &quot;Users/nphillips/Desktop/pirates.txt&quot;, # Save the file as pirates.txt to my desktop sep = &quot;\\t&quot;) # Make the columns tab-delimited 9.6.2 read.table() If you have a .txt file that you want to read into R, use the read.table() function. Argument Description file The document’s file path relative to the working directory unless specified otherwise. For example file = &quot;mydata.txt&quot; looks for the text file directly in the working directory, while file = &quot;data/mydata.txt&quot; will look for the file in an existing folder called data inside the working directory.If the file is outside of your working directory, you can also specify a full file path (file = &quot;/Users/CaptainJack/Desktop/OctoberStudy/mydata.txt&quot;) header A logical value indicating whether the data has a header row – that is, whether the first row of the data represents the column names. sep A string indicating how the columns are separated. For comma separated files, use sep = &quot;,&quot;, for tab–delimited files, use sep = &quot;\\t&quot; stringsAsFactors A logical value indicating whether or not to convert strings to factors. I always set this to FALSE because I hate, hate, hate how R uses factors The three critical arguments to read.table() are file, sep, header and stringsAsFactors. The file argument is a character value telling R where to find the file. If the file is in in a folder in your working directory, just specify the path within your working directory (e.g.; file = data/newdata.txt. The sep argument tells R how the columns are separated in the file (again, for a comma–separated file, use sep = &quot;,&quot;}, for a tab–delimited file, use sep = &quot;\\t&quot;. The header argument is a logical value (TRUE or FALSE) telling R whether or not the first row in the data is the name of the data columns. Finally, the stringsAsFactors argument is a logical value indicating whether or not to convert strings to factors (I always set this to FALSE!) Let’s test this function out by reading in a text file titled mydata.txt. Since the text file is located a folder called data in my working directory, I’ll use the file path file = &quot;data/mydata.txt&quot; and since the file is tab–delimited, I’ll use the argument sep = &quot;\\t&quot;: # Read a tab-delimited text file called mydata.txt # from the data folder in my working directory into # R and store as a new object called mydata mydata &lt;- read.table(file = &#39;data/mydata.txt&#39;, # file is in a data folder in my working directory sep = &#39;\\t&#39;, # file is tab--delimited header = TRUE, # the first row of the data is a header row stringsAsFactors = FALSE) # do NOT convert strings to factors!! 9.6.3 Reading files directly from a web URL A really neat feature of the read.table() function is that you can use it to load text files directly from the web (assuming you are online). To do this, just set the file path to the document’s web URL (beginning with http://). For example, I have a text file stored at http://goo.gl/jTNf6P. You can import and save this tab–delimited text file as a new object called fromweb as follows: # Read a text file from the web fromweb &lt;- read.table(file = &#39;http://goo.gl/jTNf6P&#39;, sep = &#39;\\t&#39;, header = TRUE) # Print the result fromweb ## message randomdata ## 1 Congratulations! 1 ## 2 you 2 ## 3 just 3 ## 4 downloaded 4 ## 5 this 5 ## 6 table 6 ## 7 from 7 ## 8 the 8 ## 9 web! 9 I think this is pretty darn cool. This means you can save your main data files on Dropbox or a web-server, and always have access to it from any computer by accessing it from its web URL. Debugging When you run read.table(), you might receive an error like this: Error in file(file, “rt”) : cannot open the connection In addition: Warning message: In file(file, “rt”) : cannot open file ‘asdf’: No such file or directory If you receive this error, it’s likely because you either spelled the file name incorrectly, or did not specify the correct directory location in the file argument. 9.7 Excel, SPSS, and other data files A common question I hear is “How can I import an SPSS/Excel/… file into R?”. The first answer to this question I always give is “You shouldn’t”. Shitty Piece of Shitty Shit files can contain information like variable descriptions that R doesn’t know what to do with, and Excel files often contain something, like missing rows or cells with text instead of numbers, that can completely confuse R. Rather than trying to import SPSS or Excel files directly in R, I always recommend first exporting/saving the original SPSS or Excel files as text .txt. files – both SPSS and Excel have options to do this. Then, once you have exported the data to a .txt file, you can read it into R using read.table(). Warning: If you try to export an Excel file to a text file, it is a good idea to clean the file as much as you can first by, for example, deleting unnecessary columns, making sure that all numeric columns have numeric data, making sure the column names are simple (ie., single words without spaces or special characters). If there is anything ‘unclean’ in the file, then R may still have problems reading it, even after you export it to a text file. If you absolutely have to read a non-text file into R, check out the package called foreign (install.packages(&quot;foreign&quot;)). This package has functions for importing Stata, SAS and SPSS files directly into R. To read Excel files, try the package xlsx (install.packages(&quot;xlsx&quot;)). But again, in my experience it’s always better to convert such files to simple text files first, and then read them into R with read.table(). 9.8 Additional tips There are many functions other than read.table() for importing data. For example, the functions read.csv and read.delim are specific for importing comma-separated and tab-separated text files. In practice, these functions do the same thing as read.table, but they don’t require you to specify a sep argument. Personally, I always use read.table() because it always works and I don’t like trying to remember unnecessary functions. 9.9 Test your R Might! In RStudio, open a new R Project in a new directory by clicking File – New Project. Call the directory MyRProject, and then select a directory on your computer for the project. This will be the project’s working directory. Outside of RStudio, navigate to the directory you selected in Question 1 and create three new folders – Call them data,R, andnotes`. Go back to RStudio and open a new R script. Save the script as CreatingObjects.R in the R folder you created in Question 2. In the script, create new objects called a, b, and c. You can assign anything to these objects – from vectors to dataframes. If you can’t think of any, use these: a &lt;- data.frame(&quot;sex&quot; = c(&quot;m&quot;, &quot;f&quot;, &quot;m&quot;), &quot;age&quot; = c(19, 43, 25), &quot;favorite.movie&quot; = c(&quot;Moon&quot;, &quot;The Goonies&quot;, &quot;Spice World&quot;)) b &lt;- mean(a$age) c &lt;- table(a$sex) Send the code to the Console so the objects are stored in your current workspace. Use the ls() function to see that the objects are indeed stored in your workspace. I have a tab–delimited text file called club at the following web address: http://nathanieldphillips.com/wp-content/uploads/2015/12/club.txt. Using read.table(), load the data as a new object called club.df in your workspace. Using write.table(), save the dataframe as a tab–delimited text file called club.txt to the data folder you created in Question 2. Note: You won’t use the text file again for this exercise, but now you have it handy in case you need to share it with someone who doesn’t use R. Save the three objects a, b, c, and club.df to an .RData file called “myobjects.RData” in your data folder using save(). Clear your workspace using the rm(list = ls()) function. Then, run the ls() function to make sure the objects are gone. Open a new R script called AnalyzingObjects.R and save the script to the R folder you created in Question 2. Now, in your AnalyzingObjects.R script, load the objects back into your workspace from the myobjects.RData file using the load() function. Again, run the ls() function to make sure all the objects are back in your workspace. Add some R code to your AnalyzingObjects.R script. Calculate some means and percentages. Now save your AnalyzingObjects.R script, and then save all the objects in your workspace to myobjects.RData. Congratulations! You are now a well-organized R Pirate! Quit RStudio and go outside for some relaxing pillaging. "],
["advanceddataframe.html", "Chapter 10 Advanced dataframe manipulation 10.1 order(): Sorting data 10.2 merge(): Combining data 10.3 aggregate(): Grouped aggregation 10.4 dplyr 10.5 Additional aggregation functions 10.6 Test your R might!: Mmmmm…caffeine", " Chapter 10 Advanced dataframe manipulation Figure 10.1: Make your dataframes dance for you In this chapter we’ll cover some more advanced functions and procedures for manipulating dataframes. # Exam data exam &lt;- data.frame( id = 1:5, q1 = c(1, 5, 2, 3, 2), q2 = c(8, 10, 9, 8, 7), q3 = c(3, 7, 4, 6, 4)) # Demographic data demographics &lt;- data.frame( id = 1:5, sex = c(&quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;), age = c(25, 22, 24, 19, 23)) # Combine exam and demographics combined &lt;- merge(x = exam, y = demographics, by = &quot;id&quot;) # Mean q1 score for each sex aggregate(formula = q1 ~ sex, data = combined, FUN = mean) ## sex q1 ## 1 f 2.0 ## 2 m 3.5 # Median q3 score for each sex, but only for those # older than 20 aggregate(formula = q3 ~ sex, data = combined, subset = age &gt; 20, FUN = mean) ## sex q3 ## 1 f 3.5 ## 2 m 5.5 # Many summary statistics by sex using dplyr! library(dplyr) combined %&gt;% group_by(sex) %&gt;% summarise( q1.mean = mean(q1), q2.mean = mean(q2), q3.mean = mean(q3), age.mean = mean(age), N = n()) ## # A tibble: 2 × 6 ## sex q1.mean q2.mean q3.mean age.mean N ## &lt;fctr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 f 2.0 8.3 4.3 23 3 ## 2 m 3.5 8.5 5.5 22 2 In Chapter 6, you learned how to calculate statistics on subsets of data using indexing. However, you may have noticed that indexing is not very intuitive and not terribly efficient. If you want to calculate statistics for many different subsets of data (e.g.; mean birth rate for every country), you’d have to write a new indexing command for each subset, which could take forever. Thankfully, R has some great built-in functions like aggregate() that allow you to easily apply functions (like mean()) to a dependent variable (like birth rate) for each level of one or more independent variables (like a country) with just a few lines of code. 10.1 order(): Sorting data To sort the rows of a dataframe according to column values, use the order() function. The order() function takes one or more vectors as arguments, and returns an integer vector indicating the order of the vectors. You can use the output of order() to index a dataframe, and thus change its order. Let’s re-order the pirates data by height from the shortest to the tallest: # Sort the pirates dataframe by height pirates &lt;- pirates[order(pirates$height),] # Look at the first few rows and columns of the result pirates[1:5, 1:4] ## id sex age height ## 39 39 female 25 130 ## 854 854 female 25 130 ## 30 30 female 26 135 ## 223 223 female 28 135 ## 351 351 female 36 137 By default, the order() function will sort values in ascending (increasing) order. If you want to order the values in descending (decreasing) order, just add the argument decreasing = TRUE to the order() function: # Sort the pirates dataframe by height in decreasing order pirates &lt;- pirates[order(pirates$height, decreasing = TRUE),] # Look at the first few rows and columns of the result pirates[1:5, 1:4] ## id sex age height ## 2 2 male 31 209 ## 793 793 male 25 209 ## 430 430 male 26 201 ## 292 292 male 29 201 ## 895 895 male 27 201 To order a dataframe by several columns, just add additional arguments to order(). For example, to order the pirates by sex and then by height, we’d do the following: # Sort the pirates dataframe by sex and then height pirates &lt;- pirates[order(pirates$sex, pirates$height),] By default, the order() function will sort values in ascending (increasing) order. If you want to order the values in descending (decreasing) order, just add the argument decreasing = TRUE to the order() function: # Sort the pirates dataframe by height in decreasing order pirates &lt;- pirates[order(pirates$height, decreasing = TRUE),] 10.2 merge(): Combining data Argument Description x, y Two dataframes to be merged by A string vector of 1 or more columns to match the data by. For example, by = &quot;id&quot; will combine columns that have matching values in a column called &quot;id&quot;. by = c(&quot;last.name&quot;, &quot;first.name&quot;) will combine columns that have matching values in both &quot;last.name&quot; and &quot;first.name&quot; all A logical value indicating whether or not to include rows with non-matching values of by. One of the most common data management tasks is merging (aka combining) two data sets together. For example, imagine you conduct a study where 5 participants are given a score from 1 to 5 on a risk assessment task. We can represent these data in a dataframe called risk.survey: Table 10.1: Results from a survey on risk. participant risk.score 1 3 2 4 3 5 4 3 5 1 # Results from a risk survey risk.survey &lt;- data.frame( &quot;participant&quot; = c(1, 2, 3, 4, 5), &quot;risk.score&quot; = c(3, 4, 5, 3, 1)) Now, imagine that in a second study, you have participants complete a survey about their level of happiness (on a scale of 0 to 100). We can represent these data in a new dataframe called happiness.survey: happiness.survey &lt;- data.frame( &quot;participant&quot; = c(4, 2, 5, 1, 3), &quot;happiness.score&quot; = c(20, 40, 50, 90, 53)) Now, we’d like to combine these data into one data frame so that the two survey scores for each participant are contained in one object. To do this, use merge(). When you merge two dataframes, the result is a new dataframe that contains data from both dataframes. The key argument in merge() is by. The by argument specifies how rows should be matched during the merge. Usually, this will be something like an name, id number, or some other unique identifier. Let’s combine our risk and happiness survey using merge(). Because we want to match rows by the participant.id column, we’ll specify by = &quot;participant.id&quot;. Additionally, because we want to include rows with potentially non-matching values, we’ll include all = TRUE # Combine the risk and happiness surveys by matching participant.id combined.survey &lt;- merge(x = risk.survey, y = happiness.survey, by = &quot;participant&quot;, all = TRUE) # Print the result combined.survey ## participant risk.score happiness.score ## 1 1 3 90 ## 2 2 4 40 ## 3 3 5 53 ## 4 4 3 20 ## 5 5 1 50 For the rest of the chapter, we’ll cover data aggregation functions. These functions allow you to quickly and easily calculate aggregated summary statistics over groups of data in a data frame. For example, you can use them to answer questions such as “What was the mean crew age for each ship?”, or “What percentage of participants completed an attention check for each study condition?” We’ll start by going over the aggregate() function. 10.3 aggregate(): Grouped aggregation Argument Description formula A formula in the form y ~ x1 + x2 + ... where y is the dependent variable, and x1, x2… are the independent variables. For example, salary ~ sex + age will aggregate a salary column at every unique combination of sex and age FUN A function that you want to apply to y at every level of the independent variables. E.g.; mean, or max. data The dataframe containing the variables in formula subset A subset of data to analyze. For example, subset(sex == &quot;f&quot; &amp; age &gt; 20) would restrict the analysis to females older than 20. You can ignore this argument to use all data. The first aggregation function we’ll cover is aggregate(). Aggregate allows you to easily answer questions in the form: “What is the value of the function FUN applied to a dependent variable dv at each level of one (or more) independent variable(s) iv? # General structure of aggregate() aggregate(formula = dv ~ iv, # dv is the data, iv is the group FUN = fun, # The function you want to apply data = df) # The dataframe object containing dv and iv Let’s give aggregate() a whirl. No…not a whirl…we’ll give it a spin. Definitely a spin. We’ll use aggregate() on the ChickWeight dataset to answer the question “What is the mean weight for each diet?” If we wanted to answer this question using basic R functions, we’d have to write a separate command for each supplement like this: # The WRONG way to do grouped aggregation. # We should be using aggregate() instead! mean(ChickWeight$weight[ChickWeight$Diet == 1]) ## [1] 103 mean(ChickWeight$weight[ChickWeight$Diet == 2]) ## [1] 123 mean(ChickWeight$weight[ChickWeight$Diet == 3]) ## [1] 143 mean(ChickWeight$weight[ChickWeight$Diet == 4]) ## [1] 135 If you are ever writing code like this, there is almost always a simpler way to do it. Let’s replace this code with a much more elegant solution using aggregate().For this question, we’ll set the value of the dependent variable Y to weight, x1 to Diet, and FUN to mean # Calculate the mean weight for each value of Diet aggregate(formula = weight ~ Diet, # DV is weight, IV is Diet FUN = mean, # Calculate the mean of each group data = ChickWeight) # dataframe is ChickWeight ## Diet weight ## 1 1 103 ## 2 2 123 ## 3 3 143 ## 4 4 135 As you can see, the aggregate() function has returned a dataframe with a column for the independent variable Diet, and a column for the results of the function mean applied to each level of the independent variable. The result of this function is the same thing we’d got from manually indexing each level of Diet individually – but of course, this code is much simpler and more elegant! You can also include a subset argument within an aggregate() function to apply the function to subsets of the original data. For example, if I wanted to calculate the mean chicken weights for each diet, but only when the chicks are less than 10 weeks old, I would do the following: # Calculate the mean weight for each value of Diet, # But only when chicks are less than 10 weeks old aggregate(formula = weight ~ Diet, # DV is weight, IV is Diet FUN = mean, # Calculate the mean of each group subset = Time &lt; 10, # Only when Chicks are less than 10 weeks old data = ChickWeight) # dataframe is ChickWeight ## Diet weight ## 1 1 58 ## 2 2 63 ## 3 3 66 ## 4 4 69 You can also include multiple independent variables in the formula argument to aggregate(). For example, let’s use aggregate() to now get the mean weight of the chicks for all combinations of both Diet and Time, but now only for weeks 0, 2, and 4: # Calculate the mean weight for each value of Diet and Time, # But only when chicks are 0, 2 or 4 weeks okd aggregate(formula = weight ~ Diet + Time, # DV is weight, IVs are Diet and Time FUN = mean, # Calculate the mean of each group subset = Time %in% c(0, 2, 4), # Only when Chicks are 0, 2, and 4 weeks old data = ChickWeight) # dataframe is ChickWeight ## Diet Time weight ## 1 1 0 41 ## 2 2 0 41 ## 3 3 0 41 ## 4 4 0 41 ## 5 1 2 47 ## 6 2 2 49 ## 7 3 2 50 ## 8 4 2 52 ## 9 1 4 56 ## 10 2 4 60 ## 11 3 4 62 ## 12 4 4 64 10.4 dplyr The dplyr package is a relatively new R package that allows you to do all kinds of analyses quickly and easily. It is especially useful for creating tables of summary statistics across specific groups of data. In this section, we’ll go over a very brief overview of how you can use dplyr to easily do grouped aggregation. Just to be clear - you can use dplyr to do everything the aggregate() function does and much more! However, this will be a very brief overview and I strongly recommend you look at the help menu for dplyr for additional descriptions and examples. To use the dplyr package, you first need to install it with install.packages() and load it: install.packages(&quot;dplyr&quot;) # Install dplyr (only necessary once) library(&quot;dplyr&quot;) # Load dplyr Programming with dplyr looks a lot different than programming in standard R. dplyr works by combining objects (dataframes and columns in dataframes), functions (mean, median, etc.), and verbs (special commands in dplyr). In between these commands is a new operator called the pipe which looks like this: %&gt;%}. The pipe simply tells R that you want to continue executing some functions or verbs on the object you are working on. You can think about this pipe as meaning ‘and then…’ To aggregate data with dplyr, your code will look something like the following code. In this example, assume that the dataframe you want to summarize is called my.df, the variable you want to group the data by independent variables iv1, iv2, and the columns you want to aggregate are called col.a, col.b and col.c # Template for using dplyr my.df %&gt;% # Specify original dataframe filter(iv3 &gt; 30) %&gt;% # Filter condition group_by(iv1, iv2) %&gt;% # Grouping variable(s) summarise( a = mean(col.a), # calculate mean of column col.a in my.df b = sd(col.b), # calculate sd of column col.b in my.df c = max(col.c)) # calculate max on column col.c in my.df, ... When you use dplyr, you write code that sounds like: “The original dataframe is XXX, now filter the dataframe to only include rows that satisfy the conditions YYY, now group the data at each level of the variable(s) ZZZ, now summarize the data and calculate summary functions XXX…” Let’s start with an example: Let’s create a dataframe of aggregated data from the pirates dataset. I’ll filter the data to only include pirates who wear a headband. I’ll group the data according to the columns sex and college. I’ll then create several columns of different summary statistic of some data across each grouping. To create this aggregated data frame, I will use the new function group_by and the verb summarise. I will assign the result to a new dataframe called pirates.agg: pirates.agg &lt;- pirates %&gt;% # Start with the pirates dataframe filter(headband == &quot;yes&quot;) %&gt;% # Only pirates that wear hb group_by(sex, college) %&gt;% # Group by these variables summarise( age.mean = mean(age), # Define first summary... tat.med = median(tattoos), # you get the idea... n = n() # How many are in each group? ) # End # Print the result pirates.agg ## Source: local data frame [6 x 5] ## Groups: sex [?] ## ## sex college age.mean tat.med n ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 female CCCC 26 10 206 ## 2 female JSSFP 34 10 203 ## 3 male CCCC 23 10 358 ## 4 male JSSFP 32 10 85 ## 5 other CCCC 25 10 24 ## 6 other JSSFP 32 12 11 As you can see from the output on the right, our final object pirates.agg is the aggregated dataframe we want which aggregates all the columns we wanted for each combination of sex and college One key new function here is n(). This function is specific to dplyr and returns a frequency of values in a summary command. Let’s do a more complex example where we combine multiple verbs into one chunk of code. We’ll aggregate data from the movies dataframe. movies %&gt;% # From the movies dataframe... filter(genre != &quot;Horror&quot; &amp; time &gt; 50) %&gt;% # Select only these rows group_by(rating, sequel) %&gt;% # Group by rating and sequel summarise( # frequency = n(), # How many movies in each group? budget.mean = mean(budget, na.rm = T), # Mean budget? revenue.mean = mean(revenue.all), # Mean revenue? billion.p = mean(revenue.all &gt; 1000)) # Percent of movies with revenue &gt; 1000? ## Source: local data frame [14 x 6] ## Groups: rating [?] ## ## rating sequel frequency budget.mean revenue.mean billion.p ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 G 0 59 41.23 234 0.0000 ## 2 G 1 12 92.92 357 0.0833 ## 3 NC-17 0 2 3.75 18 0.0000 ## 4 Not Rated 0 84 1.74 56 0.0000 ## 5 Not Rated 1 12 0.67 66 0.0000 ## 6 PG 0 312 51.78 191 0.0096 ## 7 PG 1 62 77.21 372 0.0161 ## 8 PG-13 0 645 52.09 168 0.0062 ## 9 PG-13 1 120 124.16 524 0.1167 ## 10 R 0 623 31.38 109 0.0000 ## 11 R 1 42 58.25 226 0.0000 ## 12 &lt;NA&gt; 0 86 1.65 34 0.0000 ## 13 &lt;NA&gt; 1 15 5.51 48 0.0000 ## 14 &lt;NA&gt; NA 11 0.00 34 0.0000 As you can see, our result is a dataframe with 14 rows and 6 columns. The data are summarized from the movie dataframe, only include values where the genre is not Horror and the movie length is longer than 50 minutes, is grouped by rating and sequel, and shows several summary statistics. 10.4.1 Additional dplyr help We’ve only scratched the surface of what you can do with dplyr. In fact, you can perform almost all of your R tasks, from loading, to managing, to saving data, in the dplyr framework. For more tips on using dplyr, check out the dplyr vignette at https://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html. Or open it in RStudio by running the following command: # Open the dplyr introduction in R vignette(&quot;introduction&quot;, package = &quot;dplyr&quot;) There is also a very nice YouTube video covering dplyr at https://goo.gl/UY2AE1. Finally, consider also reading R for Data Science written by Garrett Grolemund and Hadley Wickham, which teaches R from the ground-up using the dplyr framework. 10.5 Additional aggregation functions There are many, many other aggregation functions that I haven’t covered in this chapter – mainly because I rarely use them. In fact, that’s a good reminder of a peculiarity about R, there are many methods to achieve the same result, and your choice of which method to use will often come down to which method you just like the most. 10.5.1 rowMeans(), colMeans() To easily calculate means (or sums) across all rows or columns in a matrix or dataframe, use rowMeans(), colMeans(), rowSums() or colSums(). For example, imagine we have the following data frame representing scores from a quiz with 5 questions, where each row represents a student, and each column represents a question. Each value can be either 1 (correct) or 0 (incorrect) Table 10.2: Scores from an exam. q1 q2 q3 q4 q5 1 1 1 1 1 0 0 0 1 0 0 1 1 1 0 0 1 0 1 1 0 0 0 1 1 # Some exam scores exam &lt;- data.frame(&quot;q1&quot; = c(1, 0, 0, 0, 0), &quot;q2&quot; = c(1, 0, 1, 1, 0), &quot;q3&quot; = c(1, 0, 1, 0, 0), &quot;q4&quot; = c(1, 1, 1, 1, 1), &quot;q5&quot; = c(1, 0, 0, 1, 1)) Let’s use rowMeans() to get the average scores for each student: # What percent did each student get correct? rowMeans(exam) ## [1] 1.0 0.2 0.6 0.6 0.4 Now let’s use colMeans() to get the average scores for each question: # What percent of students got each question correct? colMeans(exam) ## q1 q2 q3 q4 q5 ## 0.2 0.6 0.4 1.0 0.6 Warning rowMeans() and colMeans() only work on numeric columns. If you try to apply them to non-numeric data, you’ll receive an error. 10.5.2 apply family There is an entire class of apply functions in R that apply functions to groups of data. For example, tapply(), sapply() and lapply() each work very similarly to aggregate(). For example, you can calculate the average length of movies by genre with tapply() as follows. with(movies, tapply(X = time, # DV is time INDEX = genre, # IV is genre FUN = mean, # function is mean na.rm = TRUE)) # Ignore missing ## Action Adventure Black Comedy ## 113 106 113 ## Comedy Concert/Performance Documentary ## 99 78 69 ## Drama Horror Multiple Genres ## 116 99 114 ## Musical Reality Romantic Comedy ## 113 44 107 ## Thriller/Suspense Western ## 112 121 tapply(), sapply(), and lapply() all work very similarly, their main difference is in the structure of their output. For example, lapply() returns a list (we’ll cover lists in a future chapter). 10.6 Test your R might!: Mmmmm…caffeine You’re in charge of analyzing the results of an experiment testing the effects of different forms of caffeine on a measure of performance. In the experiment, 100 participants were given either Green tea or coffee, in doses of either 1 or 5 servings. They then performed a cognitive test where higher scores indicate better performance. The data are stored in a tab–delimited dataframe at the following link: https://raw.githubusercontent.com/ndphillips/ThePiratesGuideToR/master/data/caffeinestudy.txt Load the dataset from https://raw.githubusercontent.com/ndphillips/ThePiratesGuideToR/master/data/caffeinestudy.txt as a new dataframe called caffeine. Calculate the mean age for each gender Calculate the mean age for each drink Calculate the mean age for each combined level of both gender and drink Calculate the median score for each age For men only, calculate the maximum score for each age Create a dataframe showing, for each level of drink, the mean, median, maximum, and standard deviation of scores. Only for females above the age of 20, create a table showing, for each combined level of drink and cups, the mean, median, maximum, and standard deviation of scores. Also include a column showing how many people were in each group. "],
["plotting1.html", "Chapter 11 Plotting (I) 11.1 Colors 11.2 yarrr::transparent() 11.3 High vs. low-level plotting commands 11.4 Scatterplot: plot() 11.5 Histogram: hist()", " Chapter 11 Plotting (I) Figure 11.1: The great Sammy Davis Jr. Do yourself a favor and spend an evening watching videos of him performing on YouTube. Image used entirely without permission. Sammy Davis Jr. was one of the greatest American performers of all time. If you don’t know him already, Sammy was an American entertainer who lived from 1925 to 1990. The range of his talents was just incredible. He could sing, dance, act, and play multiple instruments with ease. So how is R like Sammy Davis Jr? Like Sammy Davis Jr., R is incredibly good at doing many different things. R does data analysis like Sammy dances, and creates plot like Sammy sings. If Sammy and R did just one of these things, they’d be great. The fact that they can do both is pretty amazing. When you evaluate plotting functions in R, R can build the plot in different locations. The default location for plots is in a temporary plotting window within your R programming environment. In RStudio, plots will show up in the Plot window (typically on the bottom right hand window pane). In Base R, plots will show up in a Quartz window. You can think of these plotting locations as canvases. You only have one canvas active at any given time, and any plotting command you run will put more plotting elements on your active canvas. Certain high–level plotting functions like plot() and hist() create brand new canvases, while other low–level plotting functions like points() and segments() place elements on top of existing canvases. Don’t worry if that’s confusing for now – we’ll go over all the details soon. Let’s start by looking at a basic scatterplot in R using the plot() function. When you execute the following code, you should see a plot open in a new window: # A basic scatterplot plot(x = 1:10, y = 1:10, xlab = &quot;X Axis label&quot;, ylab = &quot;Y Axis label&quot;, main = &quot;Main Title&quot;) Let’s take a look at the result. We see an x–axis, a y–axis, 10 data points, an x–axis label, a y–axis label, and a main plot title. Some of these items, like the labels and data points, were entered as arguments to the function. For example, the main arguments x and y are vectors indicating the x and y coordinates of the (in this case, 10) data points. The arguments xlab, ylab, and main set the labels to the plot. However, there were many elements that I did not specify – from the x and y axis limits, to the color of the plotting points. As you’ll discover later, you can change all of these elements (and many, many more) by specifying additional arguments to the plot() function. However, because I did not specify them, R used default values – values that R uses unless you tell it to use something else. For the rest of this chapter, we’ll go over the main plotting functions, along with the most common arguments you can use to customize the look of your plot. 11.1 Colors Most plotting functions have a color argument (usually col) that allows you to specify the color of whatever your plotting. There are many ways to specify colors in R, let’s start with the easiest ways. 11.1.1 Colors by name The easiest way to specify a color is to enter its name as a string. For example col = &quot;red&quot; is R’s default version of the color red. Of course, all the basic colors are there, but R also has tons of quirky colors like &quot;snow&quot;, &quot;papayawhip&quot; and &quot;lawngreen&quot;. Figure 11.2 shows 100 randomly selected named colors. Figure 11.2: 100 random named colors in R. To see all 657 color names in R, run the code colors(). 11.1.2 gray() The gray() function takes two arguments, level and alpha, and returns a shade of gray. For example, gray(level = 1) will return white. The second alpha argument specifies how transparent to make the color on a scale from 0 (completely transparent), to 1 (not transparent at all). The default value for alpha is 1 (not transparent at all). See Figure 11.3 for examples. Figure 11.3: Examples of gray(level, alpha) 11.2 yarrr::transparent() I don’t know about you, but I almost always find transparent colors to be more appealing than solid colors. Not only do they help you see when multiple points are overlapping, but they’re just much nicer to look at. Just look at the overlapping circles in the plot below. Unfortunately, as far as I know, base-R does not make it easy to make transparent colors. Thankfully, there is a function in the yarrr package called transparent that makes it very easy to make any color transparent. To use it, just enter the original color as the main argument orig.col, then enter how transparent you want to make it (from 0 to 1) as the second argument trans.val. You can either save the transparent color as a new color object, or use the function directly in a plotting function like I do in the scatterplot in the margin. Later on in the book, we’ll cover more advanced ways to come up with colors using color palettes (using the RColorBrewer package or the piratepal() function in the yarrr package) and functions that generate shades of colors based on numeric data (like the colorRamp2() function in the circlize package). 11.3 High vs. low-level plotting commands There are two general types of plotting commands in R: high and low-level. High level plotting commands, like plot(), hist() and pirateplot() create entirely new plots. Within these high level plotting commands, you can define the general layout of the plot - like the axis limits and plot margins. Low level plotting commands, like points(), segments(), and text() add elements to existing plots. These low level commands don’t change the overall layout of a plot - they just add to what you’ve already created. Once you are done creating a plot, you can export the plot to a pdf or jpeg using the pdf() or jpeg() functions. Or, if you’re creating documents in Markdown or Latex, you can add your plot directly to your document. 11.3.1 Plotting arguments Most plotting functions have tons of optional arguments (also called parameters) that you can use to customize virtually everything in a plot. To see all of them, look at the help menu for par by executing ?par. However, the good news is that you don’t need to specify all possible parameters you create a plot. Instead, there are only a few critical arguments that you must specify - usually one or two vectors of data. For any optional arguments that you do not specify, R will use either a default value, or choose a value that makes sense based on the data you specify. In the following examples, I will to cover the main plotting parameters for each plotting type. However, the best way to learn what you can, and can’t, do with plots, is to try to create them yourself! I think the best way to learn how to create plots is to see some examples. Let’s start with the main high-level plotting functions. 11.4 Scatterplot: plot() The most common high-level plotting function is plot(x, y). The plot() function makes a scatterplot from two vectors x and y, where the x vector indicates the x (horizontal) values of the points, and the y vector indicates the y (vertical) values. Argument Description x, y Vectors of equal length specifying the x and y values of the points type Type of plot. &quot;l&quot; means lines, &quot;p&quot; means points, &quot;b&quot; means lines and points, &quot;n&quot; means no plotting main, xlab, ylab Strings giving labels for the plot title, and x and y axes xlim, ylim Limits to the axes. For example, xlim = c(0, 100) will set the minimum and maximum of the x-axis to 0 and 100. pch An integer indicating the type of plotting symbols (see ?points and section below), or a string specifying symbols as text. For example, pch = 21 will create a two-color circle, while pch = &quot;P&quot; will plot the character &quot;P&quot;. To see all the different symbol types, run ?points. col Main color of the plotting symbols. For example col = &quot;red&quot; will create red symbols. cex A numeric vector specifying the size of the symbols (from 0 to Inf). The default size is 1. cex = 4 will make the points very large, while cex = .5 will make them very small. plot(x = 1:10, # x-coordinates y = 1:10, # y-coordinates type = &quot;b&quot;, # Draw lines with points main = &quot;My First Plot&quot;, xlab = &quot;This is the x-axis label&quot;, ylab = &quot;This is the y-axis label&quot;, xlim = c(0, 11), # Min and max values for x-axis ylim = c(0, 11), # Min and max values for y-axis col = &quot;blue&quot;, # Color of the points pch = 16, # Type of symbol (16 means Filled circle) cex = 1 # Size of the symbols ) Aside from the x and y arguments, all of the arguments are optional. If you don’t specify a specific argument, then R will use a default value, or try to come up with a value that makes sense. For example, if you don’t specify the xlim and ylim arguments, R will set the limits so that all the points fit inside the plot. 11.4.1 Symbol types: pch When you create a plot with plot() (or points with points()), you can specify the type of symbol with the pch argument. You can specify the symbol type in one of two ways: with an integer, or with a string. If you use a string (like &quot;p&quot;), R will use that text as the plotting symbol. If you use an integer value, you’ll get the symbol that correspond to that number. See Figure for all the symbol types you can specify with an integer. Symbols differ in their shape and how they are colored. Symbols 1 through 14 only have borders and are always empty, while symbols 15 through 20 don’t have a border and are always filled. Symbols 21 through 25 have both a border and a filling. To specify the border color or background for symbols 1 through 20, use the col argument. For symbols 21 through 25, you set the color of the border with col, and the color of the background using bg Figure 11.4: The symbol types associated with the pch plotting parameter. Let’s look at some different symbol types in action: 11.5 Histogram: hist() Histograms are the most common way to plot unidimensional numeric data. To create a histogram we’ll use the hist() function. The main argument to hist() is a x, a vector of numeric data. If you want to specify how the histogram bins are created, you can use the breaks argument. To change the color of the border or background of the bins, use col and border: Let’s create a histogram of the weights in the ChickWeight dataset: hist(x = ChickWeight$weight, main = &quot;Chicken Weights&quot;, xlab = &quot;Weight&quot;, xlim = c(0, 500)) We can get more fancy by adding additional arguments like breaks = 20 to force there to be 20 bins, and col = &quot;papayawhip&quot; and bg = &quot;hotpink&quot; to make it a bit more colorful: hist(x = ChickWeight$weight, main = &quot;Fancy Chicken Weight Histogram&quot;, xlab = &quot;Weight&quot;, ylab = &quot;Frequency&quot;, breaks = 20, # 20 Bins xlim = c(0, 500), col = &quot;papayawhip&quot;, # Filling Color border = &quot;hotpink&quot;) # Border Color If you want to plot two histograms on the same plot, for example, to show the distributions of two different groups, you can use the argument to the second plot. hist(x = ChickWeight$weight[ChickWeight$Diet == 1], main = &quot;Two Histograms in one&quot;, xlab = &quot;Weight&quot;, ylab = &quot;Frequency&quot;, breaks = 20, xlim = c(0, 500), col = gray(0, .5)) hist(x = ChickWeight$weight[ChickWeight$Diet == 2], breaks = 30, add = TRUE, # Add plot to previous one! col = gray(1, .8)) "],
["solutions.html", "Chapter 12 Solutions 12.1 Chapter 4: The Basics 12.2 Chapter 5: Scalers and vectors 12.3 Chapter 6: Vector Functions 12.4 Chapter 7: Indexing vectors with [] 12.5 Chapter 8: Matrices and Dataframes", " Chapter 12 Solutions 12.1 Chapter 4: The Basics Which (if any) of the following objects names is/are invalid? thisone &lt;- 1 THISONE &lt;- 2 this.one &lt;- 3 This.1 &lt;- 4 ThIS.....ON...E &lt;- 5 This!One! &lt;- 6 # only this one! lkjasdfkjsdf &lt;- 7 2015 was a good year for pirate booty - your ship collected 100,000 gold coins. Create an object called and assign the correct value to it. gold.in.2015 &lt;- 100800 Oops, during the last inspection we discovered that one of your pirates Skippy McGee hid 800 gold coins in his underwear. Go ahead and add those gold coins to the object gold.in.2015. Next, create an object called plank.list with the name of the pirate thief. gold.in.2015 &lt;- gold.in.2015 + 800 plank.list &lt;- &quot;Skippy McGee&quot; Look at the code below. What will R return after the third line? Make a prediction, then test the code yourself. a &lt;- 10 a + 10 a # It will return 10 because we never re-assigned a! 12.2 Chapter 5: Scalers and vectors Create the vector [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] in three ways: once using c(), once using a:b, and once using seq(). c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 seq(from = 1, to = 10, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 Create the vector [2.1, 4.1, 6.1, 8.1] in two ways, once using c() and once using seq() c(2.1, 6.1, 6.1, 8.1) ## [1] 2.1 6.1 6.1 8.1 seq(from = 2.1, to = 8.1, by = 2) ## [1] 2.1 4.1 6.1 8.1 Create the vector [0, 5, 10, 15] in 3 ways: using c(), seq() with a by argument, and seq() with a length.out argument. c(0, 5, 10, 15) ## [1] 0 5 10 15 seq(from = 0, to = 15, by = 5) ## [1] 0 5 10 15 seq(from = 0, to = 15, length.out = 4) ## [1] 0 5 10 15 Create the vector [101, 102, 103, 200, 205, 210, 1000, 1100, 1200] using a combination of the c() and seq() functions c(seq(from = 101, to = 103, by = 3), seq(from = 200, to = 210, by = 5), seq(from = 1000, to = 1200, by = 100)) ## [1] 101 200 205 210 1000 1100 1200 A new batch of 100 pirates are boarding your ship and need new swords. You have 10 scimitars, 40 broadswords, and 50 cutlasses that you need to distribute evenly to the 100 pirates as they board. Create a vector of length 100 where there is 1 scimitar, 4 broadswords, and 5 cutlasses in each group of 10. That is, in the first 10 elements there should be exactly 1 scimitar, 4 broadswords and 5 cutlasses. The next 10 elements should also have the same number of each sword (and so on). swords &lt;- rep(c(&quot;scimitar&quot;, rep(&quot;broadswoard&quot;, 4), rep(&quot;cutlass&quot;, 5)), times = 100) head(swords) ## [1] &quot;scimitar&quot; &quot;broadswoard&quot; &quot;broadswoard&quot; &quot;broadswoard&quot; &quot;broadswoard&quot; ## [6] &quot;cutlass&quot; Create a vector that repeats the integers from 1 to 5, 10 times. That is [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …]. The length of the vector should be 50! rep(1:5, times = 10) ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 ## [36] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 Now, create the same vector as before, but this time repeat 1, 10 times, then 2, 10 times, etc., That is [1, 1, 1, …, 2, 2, 2, …, … 5, 5, 5]. The length of the vector should also be 50 rep(1:5, each = 10) ## [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 ## [36] 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 Create a vector containing 50 samples from a Normal distribution with a population mean of 20 and standard deviation of 2. rnorm(n = 50, mean = 20, sd = 2) ## [1] 20 20 22 20 19 19 17 18 22 19 22 25 20 20 24 19 20 17 16 18 18 20 17 ## [24] 18 15 21 23 20 18 19 20 18 18 19 22 20 22 24 20 15 22 19 22 15 20 21 ## [47] 18 24 20 22 Create a vector containing 25 samples from a Uniform distribution with a lower bound of -100 and an upper bound of -50. runif(n = 25, min = -100, max = -50) ## [1] -75 -52 -53 -99 -63 -91 -89 -92 -57 -53 -60 -98 -67 -85 -84 -99 -95 ## [18] -76 -58 -94 -95 -53 -91 -95 -79 12.3 Chapter 6: Vector Functions Create a vector that shows the square root of the integers from 1 to 10. (1:10) ^ .5 ## [1] 1.0 1.4 1.7 2.0 2.2 2.4 2.6 2.8 3.0 3.2 #or sqrt(1:10) ## [1] 1.0 1.4 1.7 2.0 2.2 2.4 2.6 2.8 3.0 3.2 Renata thinks that she finds more treasure when she’s had a mug of grogg than when she doesn’t. To test this, she recorded how much treasure she found over 7 days without drinking any grogg (ie., sober), and then did the same over 7 days while drinking grogg (ie., drunk). Here are her results: Table 12.1: Renata’s treasure haul when she was sober and when she was drunk day sober drunk Monday 2 0 Tuesday 0 0 Wednesday 3 1 Thursday 1 0 Friday 0 1 Saturday 3 2 Sunday 5 2 How much treasure did Renata find on average when she was sober? What about when she was drunk? sober &lt;- c(2, 0, 3, 1, 0, 3, 5) drunk &lt;- c(0, 0, 1, 0, 1, 2, 2) mean(sober) ## [1] 2 mean(drunk) ## [1] 0.86 Using Renata’s data again, create a new vector called difference that shows how much more treasure Renata found when she was drunk and when she was not. What was the mean, median, and standard deviation of the difference? difference &lt;- sober - drunk mean(difference) ## [1] 1.1 median(difference) ## [1] 1 sd(difference) ## [1] 1.3 There’s an old parable that goes something like this. A man does some work for a king and needs to be paid. Because the man loves rice (who doesn’t?!), the man offers the king two different ways that he can be paid. You can either pay me 100 kilograms of rice, or, you can pay me as follows: get a chessboard and put one grain of rice in the top left square. Then put 2 grains of rice on the next square, followed by 4 grains on the next, 8 grains on the next…and so on, where the amount of rice doubles on each square, until you get to the last square. When you are finished, give me all the grains of rice that would (in theory), fit on the chessboard. The king, sensing that the man was an idiot for making such a stupid offer, immediately accepts the second option. He summons a chessboard, and begins counting out grains of rice one by one… Assuming that there are 64 squares on a chessboard, calculate how many grains of rice the main will receive. If one grain of rice weights 1/64000 kilograms, how many kilograms of rice did he get? Hint: If you have trouble coming up with the answer, imagine how many grains are on the first, second, third and fourth squares, then try to create the vector that shows the number of grains on each square. Once you come up with that vector, you can easily calculate the final answer with the sum() function. # First, let&#39;s create a vector of the amount of rice on each square: rice &lt;- 2 ^ (1:64) # Here are the first few spaces head(rice) ## [1] 2 4 8 16 32 64 # The result is just the sum! rice.total &lt;- sum(rice) rice.total ## [1] 3.7e+19 # How much does that weigh? Each grain weights 1/6400 kilograms: rice.kg &lt;- sum(rice) * 1/6400 rice.kg ## [1] 5.8e+15 # That&#39;s 5,800,000,000,000,000 kilograms of rice. Let&#39;s keep going.... # A kg of rice is 1,300 calories rice.cal &lt;- rice.kg * 1300 rice.cal ## [1] 7.5e+18 # How many people can that feed for a year? # A person needs about 2,250 calories a day, or 2,250 * 365 per year rice.people.year &lt;- rice.cal / (2250 * 365) rice.people.year ## [1] 9.1e+12 # So, that amount of rice could feed 9,100,000,000,000 for a year # Assuming that the averge lifespan is 70 years, how many lifespans could this feed? rice.people.life &lt;- rice.people.year / 70 rice.people.life ## [1] 1.3e+11 # Ok...so it could feed 130,000,000,000 (130 billion) people over their lives # Conclusion: King done screwed up. 12.4 Chapter 7: Indexing vectors with [] Table 12.2: Some of my favorite movies movie year boxoffice genre time rating Whatever Works 2009 35.0 Comedy 92 PG-13 It Follows 2015 15.0 Horror 97 R Love and Mercy 2015 15.0 Drama 120 R The Goonies 1985 62.0 Adventure 90 PG Jiro Dreams of Sushi 2012 3.0 Documentary 81 G There Will be Blood 2007 10.0 Drama 158 R Moon 2009 321.0 Science Fiction 97 R Spice World 1988 79.0 Comedy -84 PG-13 Serenity 2005 39.0 Science Fiction 119 PG-13 Finding Vivian Maier 2014 1.5 Documentary 84 Unrated Create new data vectors for each column. movie &lt;- c(&quot;Whatever Works&quot;, &quot;It Follows&quot;, &quot;Love and Mercy&quot;, &quot;The Goonies&quot;, &quot;Jiro Dreams of Sushi&quot;, &quot;There Will be Blood&quot;, &quot;Moon&quot;, &quot;Spice World&quot;, &quot;Serenity&quot;, &quot;Finding Vivian Maier&quot;) year &lt;- c(2009, 2015, 2015, 1985, 2012, 2007, 2009, 1988, 2005, 2014) boxoffice &lt;- c(35, 15, 15, 62, 3, 10, 321, 79, 39, 1.5) genre &lt;- c(&quot;Comedy&quot;, &quot;Horror&quot;, &quot;Drama&quot;, &quot;Adventure&quot;, &quot;Documentary&quot;, &quot;Drama&quot;, &quot;Science Fiction&quot;, &quot;Comedy&quot;, &quot;Science Fiction&quot;, &quot;Documentary&quot;) time &lt;- c(92, 97, 120, 90, 81, 158, 97, -84, 119, 84) rating &lt;- c(&quot;PG-13&quot;, &quot;R&quot;, &quot;R&quot;, &quot;PG&quot;, &quot;G&quot;, &quot;R&quot;, &quot;R&quot;, &quot;PG-13&quot;, &quot;PG-13&quot;, &quot;Unrated&quot;) What is the name of the 10th movie in the list? movie[10] ## [1] &quot;Finding Vivian Maier&quot; What are the genres of the first 4 movies? genre[1:4] ## [1] &quot;Comedy&quot; &quot;Horror&quot; &quot;Drama&quot; &quot;Adventure&quot; Some joker put Spice World in the movie names – it should be ``The Naked Gun’’ Please correct the name. movie[movie == &quot;Spice World&quot;] &lt;- &quot;The Naked Gun&quot; What were the names of the movies made before 1990? movie[year &lt; 1990] ## [1] &quot;The Goonies&quot; &quot;The Naked Gun&quot; How many movies were Dramas? What percent of the 10 movies were Comedies? sum(genre == &quot;Drama&quot;) ## [1] 2 mean(genre == &quot;Comedy&quot;) ## [1] 0.2 One of the values in the time vector is invalid. Convert any invalid values in this vector to NA. Then, calculate the mean movie time time[time &lt; 0] &lt;- NA mean(time, na.rm = TRUE) ## [1] 104 What were the names of the Comedy movies? What were their boxoffice totals? (Two separate questions) movie[genre == &quot;Comedy&quot;] ## [1] &quot;Whatever Works&quot; &quot;The Naked Gun&quot; boxoffice[genre == &quot;Comedy&quot;] ## [1] 35 79 What were the names of the movies that made less than $50 Million dollars AND were Comedies? movie[boxoffice &lt; 50 &amp; genre == &quot;Comedy&quot;] ## [1] &quot;Whatever Works&quot; What was the median boxoffice revenue of movies rated either G or PG? median(boxoffice[rating %in% c(&quot;G&quot;, &quot;PG&quot;)]) ## [1] 32 # OR median(boxoffice[rating == &quot;G&quot; | rating == &quot;PG&quot;]) ## [1] 32 What percent of the movies were either rated R OR were comedies? mean(rating == &quot;R&quot; | genre == &quot;Comedy&quot;) ## [1] 0.6 12.5 Chapter 8: Matrices and Dataframes The following table shows the results of a survey of 10 pirates. In addition to some basic demographic information, the survey asked each pirate “What is your favorite superhero?”&quot; and “How many tattoos do you have?”&quot; Name Sex Age Superhero Tattoos Astrid F 30 Batman 11 Lea F 25 Superman 15 Sarina F 25 Batman 12 Remon M 29 Spiderman 5 Letizia F 22 Batman 65 Babice F 22 Antman 3 Jonas M 35 Batman 9 Wendy F 19 Superman 13 Niveditha F 32 Maggott 900 Gioia F 21 Superman 0 Combine the data into a single dataframe. Complete all the following exercises from the dataframe! piratesurvey &lt;- data.frame( name = c(&quot;Astrid&quot;, &quot;Lea&quot;, &quot;Sarina&quot;, &quot;Remon&quot;, &quot;Letizia&quot;, &quot;Babice&quot;, &quot;Jonas&quot;, &quot;Wendy&quot;, &quot;Niveditha&quot;, &quot;Gioia&quot;), sex = c(&quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), age = c(30, 25, 25, 29, 22, 22, 35, 19, 32, 21), superhero = c(&quot;Batman&quot;, &quot;Superman&quot;, &quot;Batman&quot;, &quot;Spiderman&quot;, &quot;Batman&quot;, &quot;Antman&quot;, &quot;Batman&quot;, &quot;Superman&quot;, &quot;Maggott&quot;, &quot;Superman&quot;), tattoos = c(11, 15, 12, 5, 65, 3, 9, 13, 900, 0), stringsAsFactors = FALSE ) What is the median age of the 10 pirates? median(piratesurvey$age) ## [1] 25 What was the mean age of female and male pirates separately? mean(piratesurvey$age[piratesurvey$sex == &quot;F&quot;]) ## [1] 24 mean(piratesurvey$age[piratesurvey$sex == &quot;M&quot;]) ## [1] 32 ## OR with(piratesurvey, mean(age[sex == &quot;F&quot;])) ## [1] 24 with(piratesurvey, mean(age[sex == &quot;M&quot;])) ## [1] 32 ## OR mean(subset(piratesurvey, subset = sex == &quot;F&quot;)$age) ## [1] 24 mean(subset(piratesurvey, subset = sex == &quot;M&quot;)$age) ## [1] 32 What was the most number of tattoos owned by a male pirate? with(piratesurvey, max(tattoos[sex == &quot;M&quot;])) ## [1] 9 # OR max(subset(piratesurvey, subset = sex == &quot;M&quot;)$tattoos) ## [1] 9 What percent of pirates under the age of 32 were female? with(piratesurvey, mean(sex[age &lt; 32] == &quot;F&quot;)) ## [1] 0.88 What percent of female pirates are under the age of 32? with(piratesurvey, mean(sex[age &lt; 32] == &quot;F&quot;)) ## [1] 0.88 Add a new column to the dataframe called tattoos.per.year which shows how many tattoos each pirate has for each year in their life. piratesurvey$tattoos.per.year &lt;- with(piratesurvey, tattoos / age) Which pirate had the most number of tattoos per year? piratesurvey$name[piratesurvey$tattoos.per.year == max(piratesurvey$tattoos.per.year)] ## [1] &quot;Niveditha&quot; What are the names of the female pirates whose favorite piratesurvey is Superman? piratesurvey$name[with(piratesurvey, sex == &quot;F&quot; &amp; superhero == &quot;Superman&quot;)] ## [1] &quot;Lea&quot; &quot;Wendy&quot; &quot;Gioia&quot; What was the median number of tattoos of pirates over the age of 20 whose favorite piratesurvey is Spiderman? with(piratesurvey, (tattoos[age &gt; 20 &amp; superhero == &quot;Spiderman&quot;])) ## [1] 5 "],
["references.html", "References", " References "]
]
